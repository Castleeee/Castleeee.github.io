<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++基础 | 会走路的三百块</title>
    <meta name="description" content="年轻人的博客">
    <link rel="icon" href="/logo1.ico" type="image/x-icon">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.d22626bb.css" as="style"><link rel="preload" href="/assets/js/app.64171550.js" as="script"><link rel="preload" href="/assets/js/41.16bfab2f.js" as="script"><link rel="prefetch" href="/assets/js/10.f30e4bf5.js"><link rel="prefetch" href="/assets/js/100.14a8b555.js"><link rel="prefetch" href="/assets/js/101.9e257240.js"><link rel="prefetch" href="/assets/js/11.c050169c.js"><link rel="prefetch" href="/assets/js/12.9abd0678.js"><link rel="prefetch" href="/assets/js/13.ca763ee5.js"><link rel="prefetch" href="/assets/js/14.69f05fca.js"><link rel="prefetch" href="/assets/js/15.db5225be.js"><link rel="prefetch" href="/assets/js/16.c6de58f6.js"><link rel="prefetch" href="/assets/js/17.a33727a2.js"><link rel="prefetch" href="/assets/js/18.78f0824a.js"><link rel="prefetch" href="/assets/js/19.20a4f3cf.js"><link rel="prefetch" href="/assets/js/20.15fb9aec.js"><link rel="prefetch" href="/assets/js/21.c2410e24.js"><link rel="prefetch" href="/assets/js/22.6423d49a.js"><link rel="prefetch" href="/assets/js/23.1b0b2120.js"><link rel="prefetch" href="/assets/js/24.93132bac.js"><link rel="prefetch" href="/assets/js/25.a334198a.js"><link rel="prefetch" href="/assets/js/26.c1c7aaa3.js"><link rel="prefetch" href="/assets/js/27.2c86a0cd.js"><link rel="prefetch" href="/assets/js/28.a9d5d0ae.js"><link rel="prefetch" href="/assets/js/29.82f2e489.js"><link rel="prefetch" href="/assets/js/3.465cd447.js"><link rel="prefetch" href="/assets/js/30.d0c8250c.js"><link rel="prefetch" href="/assets/js/31.e6286844.js"><link rel="prefetch" href="/assets/js/32.116769da.js"><link rel="prefetch" href="/assets/js/33.38e22b91.js"><link rel="prefetch" href="/assets/js/34.21d15ece.js"><link rel="prefetch" href="/assets/js/35.53517849.js"><link rel="prefetch" href="/assets/js/36.9b848dcf.js"><link rel="prefetch" href="/assets/js/37.bf3574bb.js"><link rel="prefetch" href="/assets/js/38.34e99c36.js"><link rel="prefetch" href="/assets/js/39.10a54121.js"><link rel="prefetch" href="/assets/js/4.9d750d27.js"><link rel="prefetch" href="/assets/js/40.0ead9dc2.js"><link rel="prefetch" href="/assets/js/42.b0388f8b.js"><link rel="prefetch" href="/assets/js/43.1d51bbcb.js"><link rel="prefetch" href="/assets/js/44.9e15a8ac.js"><link rel="prefetch" href="/assets/js/45.c9a7ee30.js"><link rel="prefetch" href="/assets/js/46.0821d6b3.js"><link rel="prefetch" href="/assets/js/47.fdd4b2c4.js"><link rel="prefetch" href="/assets/js/48.c86a3241.js"><link rel="prefetch" href="/assets/js/49.29d7cdaf.js"><link rel="prefetch" href="/assets/js/5.b5540d72.js"><link rel="prefetch" href="/assets/js/50.88cae993.js"><link rel="prefetch" href="/assets/js/51.39b0672d.js"><link rel="prefetch" href="/assets/js/52.47b9c89c.js"><link rel="prefetch" href="/assets/js/53.561866dc.js"><link rel="prefetch" href="/assets/js/54.44ad8aef.js"><link rel="prefetch" href="/assets/js/55.999cd3f5.js"><link rel="prefetch" href="/assets/js/56.0fc25a14.js"><link rel="prefetch" href="/assets/js/57.fbeec51d.js"><link rel="prefetch" href="/assets/js/58.c2c3e960.js"><link rel="prefetch" href="/assets/js/59.388b8a2f.js"><link rel="prefetch" href="/assets/js/6.9305fa77.js"><link rel="prefetch" href="/assets/js/60.3bab7106.js"><link rel="prefetch" href="/assets/js/61.fab74e1f.js"><link rel="prefetch" href="/assets/js/62.b8451d9d.js"><link rel="prefetch" href="/assets/js/63.1ea19cc7.js"><link rel="prefetch" href="/assets/js/64.21f37b67.js"><link rel="prefetch" href="/assets/js/65.79da4678.js"><link rel="prefetch" href="/assets/js/66.2276f1ea.js"><link rel="prefetch" href="/assets/js/67.cf3e97e4.js"><link rel="prefetch" href="/assets/js/68.3b9433a6.js"><link rel="prefetch" href="/assets/js/69.a6723b19.js"><link rel="prefetch" href="/assets/js/7.8235c05c.js"><link rel="prefetch" href="/assets/js/70.eff0cc02.js"><link rel="prefetch" href="/assets/js/71.577ad016.js"><link rel="prefetch" href="/assets/js/72.ee1b8084.js"><link rel="prefetch" href="/assets/js/73.ce23853b.js"><link rel="prefetch" href="/assets/js/74.e51d0dc7.js"><link rel="prefetch" href="/assets/js/75.3fbf6e41.js"><link rel="prefetch" href="/assets/js/76.1ad79723.js"><link rel="prefetch" href="/assets/js/77.05aaa2f4.js"><link rel="prefetch" href="/assets/js/78.9e4bf317.js"><link rel="prefetch" href="/assets/js/79.028f9c41.js"><link rel="prefetch" href="/assets/js/8.a4265244.js"><link rel="prefetch" href="/assets/js/80.a83e9fee.js"><link rel="prefetch" href="/assets/js/81.e20ef630.js"><link rel="prefetch" href="/assets/js/82.0a2c28d1.js"><link rel="prefetch" href="/assets/js/83.84f22d3a.js"><link rel="prefetch" href="/assets/js/84.8c0c443d.js"><link rel="prefetch" href="/assets/js/85.1473a2e2.js"><link rel="prefetch" href="/assets/js/86.4683653f.js"><link rel="prefetch" href="/assets/js/87.9507aa61.js"><link rel="prefetch" href="/assets/js/88.77ce595e.js"><link rel="prefetch" href="/assets/js/89.d25806a8.js"><link rel="prefetch" href="/assets/js/9.56b90d44.js"><link rel="prefetch" href="/assets/js/90.231b245f.js"><link rel="prefetch" href="/assets/js/91.cb1ec410.js"><link rel="prefetch" href="/assets/js/92.10cedbd9.js"><link rel="prefetch" href="/assets/js/93.575cc043.js"><link rel="prefetch" href="/assets/js/94.9233e13a.js"><link rel="prefetch" href="/assets/js/95.fafa9bc4.js"><link rel="prefetch" href="/assets/js/96.8b941223.js"><link rel="prefetch" href="/assets/js/97.49080105.js"><link rel="prefetch" href="/assets/js/98.82d1cc72.js"><link rel="prefetch" href="/assets/js/99.d78b0b9a.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.0cd5f832.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d22626bb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div><header id="navbarWrapper" class="navbar"><div class="sidebar-button"><i class="iconfont reco-menu"></i></div> <a href="/" class="home-link router-link-active"><img src="/head3.png" alt="会走路的三百块" class="logo"> <span class="site-name">会走路的三百块</span></a> <div class="links" style="max-width:nullpx;"><div class="side-search-wrapper"><div class="search-box" data-v-1b2e3b29><input aria-label="Search" autocomplete="off" spellcheck="false" value="" data-v-1b2e3b29> <i class="iconfont reco-search" data-v-1b2e3b29></i> <!----></div></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/backEnd.html" class="nav-link"><i class="iconfont undefined"></i>
  后端
</a></li><li class="dropdown-item"><!----> <a href="/categories/frontEnd.html" class="nav-link"><i class="iconfont undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/categories/bigData.html" class="nav-link"><i class="iconfont undefined"></i>
  大数据
</a></li><li class="dropdown-item"><!----> <a href="/categories/Distributed.html" class="nav-link"><i class="iconfont undefined"></i>
  分布式
</a></li><li class="dropdown-item"><!----> <a href="/categories/life.html" class="nav-link"><i class="iconfont undefined"></i>
  日记
</a></li></ul></div></div><div class="nav-item"><a href="/tags/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tags
</a></div><div class="nav-item"><a href="/categories/article.html" class="nav-link"><i class="iconfont reco-up"></i>
  Library
</a></div><div class="nav-item"><a href="/timeLine/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/about.html" class="nav-link"><i class="iconfont reco-account"></i>
  about me
</a></div><div class="nav-item"><a href="https://www.jianshu.com/u/04777e91e2ef" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-jianshu"></i>
  简书
  </a></div><div class="nav-item"><a href="https://github.com/Castleeee" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  </a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><div class="side-search-wrapper"><div class="search-box" data-v-1b2e3b29><input aria-label="Search" autocomplete="off" spellcheck="false" value="" data-v-1b2e3b29> <i class="iconfont reco-search" data-v-1b2e3b29></i> <!----></div></div> <nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/backEnd.html" class="nav-link"><i class="iconfont undefined"></i>
  后端
</a></li><li class="dropdown-item"><!----> <a href="/categories/frontEnd.html" class="nav-link"><i class="iconfont undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/categories/bigData.html" class="nav-link"><i class="iconfont undefined"></i>
  大数据
</a></li><li class="dropdown-item"><!----> <a href="/categories/Distributed.html" class="nav-link"><i class="iconfont undefined"></i>
  分布式
</a></li><li class="dropdown-item"><!----> <a href="/categories/life.html" class="nav-link"><i class="iconfont undefined"></i>
  日记
</a></li></ul></div></div><div class="nav-item"><a href="/tags/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tags
</a></div><div class="nav-item"><a href="/categories/article.html" class="nav-link"><i class="iconfont reco-up"></i>
  Library
</a></div><div class="nav-item"><a href="/timeLine/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/about.html" class="nav-link"><i class="iconfont reco-account"></i>
  about me
</a></div><div class="nav-item"><a href="https://www.jianshu.com/u/04777e91e2ef" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-jianshu"></i>
  简书
  </a></div><div class="nav-item"><a href="https://github.com/Castleeee" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  </a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><!----></p> <ul class="sidebar-group-items"><li><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#输入输出" class="sidebar-link">输入输出</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#一些规则" class="sidebar-link">一些规则</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#标准io" class="sidebar-link">标准IO</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#文件io" class="sidebar-link">文件IO</a></li></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#函数" class="sidebar-link">函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#默认参数" class="sidebar-link">默认参数</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#函数重载" class="sidebar-link">函数重载</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#函数模板" class="sidebar-link">函数模板</a></li></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#动态内存管理" class="sidebar-link">动态内存管理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#类和对象" class="sidebar-link">类和对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#类" class="sidebar-link">类</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#构造析构" class="sidebar-link">构造析构</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#this指针" class="sidebar-link">this指针</a></li></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#面向对象" class="sidebar-link">面向对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#封装" class="sidebar-link">封装</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#继承" class="sidebar-link">继承</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#多态" class="sidebar-link">多态</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#类模板" class="sidebar-link">类模板</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#运算符重载" class="sidebar-link">运算符重载</a></li></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#异常处理" class="sidebar-link">异常处理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#stl" class="sidebar-link">STL</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#向量vector" class="sidebar-link">向量vector</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#队列queue" class="sidebar-link">队列queue</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#链表list" class="sidebar-link">链表list</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#元组tuple" class="sidebar-link">元组tuple</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#集合set" class="sidebar-link">集合set</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#映射map" class="sidebar-link">映射map</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#栈stack" class="sidebar-link">栈stack</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#字符串string" class="sidebar-link">字符串string</a></li></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/Cpp.html#参考资料列表" class="sidebar-link">参考资料列表</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page" data-v-cdcae5a4> <div class="page-title" data-v-cdcae5a4><h1 data-v-cdcae5a4>C++基础</h1> <hr data-v-cdcae5a4> <div data-v-2c25cede data-v-cdcae5a4><i class="iconfont reco-account" data-v-2c25cede><span data-v-2c25cede>会走路的三百块</span></i> <i class="iconfont reco-date" data-v-2c25cede><span data-v-2c25cede>3/22/2019</span></i> <!----> <i class="iconfont reco-tag tags" data-v-2c25cede><span class="tag-item" data-v-2c25cede>
      后端
    </span><span class="tag-item" data-v-2c25cede>
      C/C++
    </span><span class="tag-item" data-v-2c25cede>
      语言基础
    </span><span class="tag-item" data-v-2c25cede>
      所有文章
    </span></i></div></div> <div class="content" data-v-cdcae5a4><div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>因为很多东西都在C中有，这里就只看看那些没有的</p></div> <div align="center"><h1><strong>C++</strong></h1></div> <h2 id="输入输出"><a href="#输入输出" aria-hidden="true" class="header-anchor">#</a> 输入输出</h2> <h3 id="一些规则"><a href="#一些规则" aria-hidden="true" class="header-anchor">#</a> 一些规则</h3> <p><strong>命名空间</strong><br>
为了避免函数和变量名混乱我们使用命名空间来隔离开。调用的时候是<code>std::cout</code>使用了std空间里的cout函数<br>
一般用std就够了。也可以直接using namespace std使用std下的所有东西。<br> <strong>头文件引入</strong><br> <code>#include &lt; string &gt;</code> c没有string，c++引入就有了，c中很多库需要加c前缀。 <code>&lt;&gt;</code>从系统头文件中寻找，没有则报错，<code>&quot;&quot;</code>先从非系统头文件找，没有再找系统头文件，不会报错</p> <h3 id="标准io"><a href="#标准io" aria-hidden="true" class="header-anchor">#</a> 标准IO</h3> <p><code>#include &lt; iostream &gt;</code>标准输入输出流。在定义流对象时，系统会在内存中开辟一段缓冲区，用来暂存输入输出流的数据<br>
cout是标准输出流对象插入到输出流中并输出到屏幕cout&lt;&lt;x&lt;&lt;endl;<br>
cin是标准输入流对象，接受控制台输入的东西。cin&gt;&gt;x;<br>
endl是尾部换行符（关于这个更多的google去吧，暂时用到这些）</p> <h3 id="文件io"><a href="#文件io" aria-hidden="true" class="header-anchor">#</a> 文件IO</h3> <p><code>#include &lt; fstream &gt;</code>文件输入输出流。</p> <div class="language-c extra-class"><pre class="language-c"><code>ofstream <span class="token function">oF</span><span class="token punctuation">(</span><span class="token string">&quot;text.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打开一个文件对象</span>
oF<span class="token operator">&lt;&lt;</span><span class="token number">333</span><span class="token operator">&lt;&lt;</span><span class="token string">&quot;aaaaa\n&quot;</span><span class="token punctuation">;</span><span class="token comment">//写入一个txt文件里</span>
oF<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//记得关掉</span>
ifstream <span class="token function">iF</span><span class="token punctuation">(</span><span class="token string">&quot;text.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输入一个文件对象的东西</span>
<span class="token keyword">double</span> d<span class="token punctuation">;</span>
string str<span class="token punctuation">;</span>
iF<span class="token operator">&gt;&gt;</span>d<span class="token operator">&gt;&gt;</span>str<span class="token punctuation">;</span><span class="token comment">//接收变量</span>
cout<span class="token operator">&lt;&lt;</span>d<span class="token operator">&lt;&lt;</span><span class="token string">&quot;&quot;</span><span class="token operator">&lt;&lt;</span>str<span class="token comment">//打印出来看看是啥</span>
</code></pre></div><p>会txt就行了其他的不管了。</p> <h2 id="函数"><a href="#函数" aria-hidden="true" class="header-anchor">#</a> 函数</h2> <h3 id="默认参数"><a href="#默认参数" aria-hidden="true" class="header-anchor">#</a> 默认参数</h3> <p><strong>引用变量</strong></p> <blockquote><p>int a=3;
int &amp;r=a;//r是a的引用变量</p></blockquote> <p>引用变量就是给变量起了个别名，指向同一块内存空间，定义的时候必须进行初始化而且必须保证类型匹配。引用变量定义之后就不能再更改指向其他人了。
<br>主要做函数的形参。<br>
c++的函数直接放进去是值传递<code>int f（int a,int b）{...}</code>调用f（x,y）不会对外部的x,y产生影响，因为函数自己开辟堆栈空间，ab只是复制了xy的值而没有真正拿到xy
<br>
解决方法:</p> <ul><li>传入俩指针，在函数内部对指针里的值进行修改，直接对内存修改。<code>int f（int *a,int *b）{...}</code>调用f（&amp;x,&amp;y）<br></li> <li>传入两个引用，不在函数内分配内存通过引用直接修改值。<code>int f（int &amp;a,int &amp;b）{...}</code>调用f（x,y）
<strong>函数的默认参数</strong>
参数可以有默认值的，<code>int f（char r,int x=3）</code>，<strong>默认形参要靠右！</strong></li></ul> <h3 id="函数重载"><a href="#函数重载" aria-hidden="true" class="header-anchor">#</a> 函数重载</h3> <p>c++允许定义两个名字相同的函数，但<strong>形参类型必须不要相同</strong>，编译器会根据你传入的参数什么样子来调用不同的函数。
函数名和形参列表构成了函数签名，函数重载不能根据返回值来区分。注意歧义的情况。</p> <div class="language-c extra-class"><pre class="language-c"><code>留坑
</code></pre></div><h3 id="函数模板"><a href="#函数模板" aria-hidden="true" class="header-anchor">#</a> 函数模板</h3> <p>上例中的两个函数可以用函数模板进行重构。数据类型变为模板类型参数。
<code>template &lt;typename T&gt;</code>定义了一个模板T</p> <div class="language-c extra-class"><pre class="language-c"><code>留坑
</code></pre></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p> <p>注意调用时给定的数据类型是否支持函数的操作。<br>
在重载函数中也可以像函数模板一样指定类型。</p></div> <h2 id="动态内存管理"><a href="#动态内存管理" aria-hidden="true" class="header-anchor">#</a> 动态内存管理</h2> <p>C++中使用<code>new</code>代替malloc。new除了分配内存外还会对对象进行初始化（new类对象的时候会调用构造函数等）。<br> <code>new</code>完了一定要<code>delete</code>如果没被delete那么这块被分配的内存会一直存在没有名字，不被回收造成内存泄漏。</p> <div class="language-c extra-class"><pre class="language-c"><code>留坑
</code></pre></div><p>指针指向new出来的新数组的时候实质上是指向数组的首地址</p> <div class="language-c extra-class"><pre class="language-c"><code>留坑
</code></pre></div><div class="danger custom-block"><p class="custom-block-title">WARNING</p> <p>delete 掉new type[] 申请的内存必须要用**<code>delete[] p</code><strong>如果没有</strong><code>[]</code>**则只会删除数组的第一个元素值后面的元素会泄露</p></div> <h2 id="类和对象"><a href="#类和对象" aria-hidden="true" class="header-anchor">#</a> 类和对象</h2> <p>传统的面向过程编程，C++引入了面向对象编程OOP<a href="https://blog.csdn.net/it_man/article/details/6672964">随便看一看吧后面再找个好的</a></p> <h3 id="类"><a href="#类" aria-hidden="true" class="header-anchor">#</a> 类</h3> <p>面向对象编程：程序是由不同种类的许多对象相互协作完成的。对象之间通过发送/接收消息来协作完成各种任务。由这些对象构成的程序也称为“对象式系统&quot;.
<br><strong><code>class name{};</code></strong> 定义类（你要非要用struct我也管不着）。类可以生成一个对象，类是对事物的特征抽象。通过类可以定义对象
访问的时候使用**<code>.</code><strong>。<strong>对象</strong>同样具有指针
看例子</strong>注意后面有分号**</p> <div class="language-c extra-class"><pre class="language-c"><code>留坑
</code></pre></div><p>类对象可以通过指针来访问，访问符号为<code>-&gt;</code></p> <div class="language-c extra-class"><pre class="language-c"><code>class_name stu<span class="token punctuation">;</span><span class="token comment">//生成一个对象</span>
class_name <span class="token operator">*</span>object_pointer<span class="token operator">=</span><span class="token operator">&amp;</span>stu<span class="token punctuation">;</span><span class="token comment">//给指针赋值</span>
object_pointer<span class="token operator">-&gt;</span>name<span class="token punctuation">;</span><span class="token comment">//访问了属性</span>
<span class="token punctuation">(</span><span class="token operator">*</span>object_pointer<span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token comment">//访问了属性</span>

class_name <span class="token operator">*</span>object_pointer<span class="token operator">=</span>new class_name<span class="token punctuation">;</span><span class="token comment">//给指针赋动态对象（存储在堆）</span>
delete object_pointer<span class="token comment">//记得删除</span>
</code></pre></div><p>成员可以有函数(行为)和变量(属性)。函数可以先在类中声明在后面实现。</p> <h3 id="构造析构"><a href="#构造析构" aria-hidden="true" class="header-anchor">#</a> 构造析构</h3> <p><br>对象在生成的时候实际上是通过一个<code>构造函数</code>来生成的，构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void，如果不在类中定义，c++会默认给一个空的<code>默认构造函数</code>，啥都不执行。
<br>构造函数可以用来初始化成员变量。构造函数可以提供参数，在声明对象的时候就要传入对应的参数。
<br>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象(delete a;)时执行。
<br><code>析构函数</code>的名称与类的名称是完全相同的，只是在前面加波浪号<code>~</code>作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。<a href="https://www.cnblogs.com/nzbbody/p/3523064.html">构造析构</a></p> <div class="language-c extra-class"><pre class="language-c"><code>留坑
</code></pre></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p> <p>自定义了构造函数之后不会再分配默认构造函数，也就不能直接声明对象数组。<br>
student stu[3];会报错,存储指针或者用for添加进去</p></div> <h3 id="this指针"><a href="#this指针" aria-hidden="true" class="header-anchor">#</a> this指针</h3> <p>类中的成员函数自带了一个this指针。比如<code>stu.print();==&gt;print(&amp;stu);</code>把类的指针传入。<br>
void print(student *this){<br>
cout&lt;&lt;<code>this-&gt;name</code>&lt;&lt;&quot;&quot;&lt;&lt;<code>this-&gt;score</code>&lt;&lt;end1;<br>
}<br></p> <h2 id="面向对象"><a href="#面向对象" aria-hidden="true" class="header-anchor">#</a> 面向对象</h2> <h3 id="封装"><a href="#封装" aria-hidden="true" class="header-anchor">#</a> 封装</h3> <p>类中的成员默认为<code>private</code>只有本类中的成员才能调用，外部不能访问，声明一个类的时候通常要声明<code>public</code>和<code>private</code>.
一般成员不声明设置为private，通过get/set方法进行设置和访问控制。参考java豆(bean)</p> <div class="language-ctypename extra-class"><pre class="language-text"><code>留坑
</code></pre></div><p>封装是为了安全考虑。</p> <table><thead><tr><th style="text-align:center">属性</th> <th style="text-align:left">访问</th></tr></thead> <tbody><tr><td style="text-align:center">private</td> <td style="text-align:left">能由1.该类中的函数2.其友元函数访问 不能被任何其他访问 该类的对象也不能访问</td></tr> <tr><td style="text-align:center">protected</td> <td style="text-align:left">能被1.该类中的函数2.子类的函数 以及3.其友元函数访问 但不能被该类的对象访问</td></tr> <tr><td style="text-align:center">public</td> <td style="text-align:left">可以被1.该类中的函数2.子类的函数3.其友元函数访问 也可以由4.该类的对象访问</td></tr></tbody></table> <p><strong>友元函数</strong><br>
类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。<br>
设为友元的普通的非成员函数,类内声明<br> <strong><code>friend void printWidth( Box box );</code></strong><br>
设为友元类中的所有成员函数,在class的public声明另一个类**<code>friend class ClassOther;</code>**<br>
有缘不会被继承传递</p> <h3 id="继承"><a href="#继承" aria-hidden="true" class="header-anchor">#</a> 继承</h3> <p>子类继承父类子类就具有了父类的函数和数据成员。<br> <strong><code>class A: public A1, private A2</code></strong><br>
在声明类的时候有三种继承方式,我们几乎不使用 protected 或 private 继承</p> <table><thead><tr><th style="text-align:center">继承规则</th> <th style="text-align:center">public</th> <th style="text-align:center">protected</th> <th style="text-align:center">private</th></tr></thead> <tbody><tr><td style="text-align:center">public继承</td> <td style="text-align:center">public</td> <td style="text-align:center">protected</td> <td style="text-align:center">不可用</td></tr> <tr><td style="text-align:center">protected继承</td> <td style="text-align:center">protected</td> <td style="text-align:center">protected</td> <td style="text-align:center">不可用</td></tr> <tr><td style="text-align:center">private继承</td> <td style="text-align:center">private</td> <td style="text-align:center">private</td> <td style="text-align:center">不可用</td></tr></tbody></table> <p>下列属性是不能被继承的</p> <ul><li>基类的构造函数、析构函数和拷贝构造函数。</li> <li>基类的重载运算符。</li> <li>基类的友元函数</li></ul> <p>可以多继承，但是要注意棱形继承多态问题<br>
简单的继承关系示例</p> <div class="language-c extra-class"><pre class="language-c"><code>留坑
</code></pre></div><h3 id="多态"><a href="#多态" aria-hidden="true" class="header-anchor">#</a> 多态</h3> <p><strong><h4>虚继承</h4></strong><br></p> <blockquote><p>class A;
class B:vitual public A;
class C:vitual public A;
class D:public B,public C;</p></blockquote> <p><strong><h4>虚基类</h4></strong><br> <strong><h4>虚函数</h4></strong><br> <strong><h4>纯虚函数</h4></strong><br> <strong><h4>抽象类(接口)</h4></strong><br>
为了解决棱形继承问题，由此有了虚继承</p> <h3 id="类模板"><a href="#类模板" aria-hidden="true" class="header-anchor">#</a> 类模板</h3> <p>C++通过类模板来实现泛型支持。和声明函数模板一样，声明一个类型**<code>template &lt;class T&gt;</code><strong>,在类中使用T类型，声明对象的时候指明类型即可Class</strong>&lt; type &gt;**(a,b)</p> <div class="language-c extra-class"><pre class="language-c"><code>留坑https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>jianshu<span class="token punctuation">.</span>com<span class="token operator">/</span>p<span class="token operator">/</span><span class="token number">70</span>ca94872418
</code></pre></div><ul><li>如果父类自定义了构造函数，记得子类要调用父类构造函数来初始化</li> <li>继承的时候，如果子类不是模板类，则必须指明当前的父类的类型，因为要分配内存空间class ChildOne:public Parent&lt; int &gt;</li> <li>继承的时候，如果子类是模板类，要么指定父类的类型，要么用子类的泛型来指定父类class ChildTwo:public Parent&lt; T &gt;
-----from <a href="http://www.runoob.com/cplusplus/cpp-templates.html">菜鸟</a>，<a href="https://www.jianshu.com/p/70ca94872418">一个人的简书</a></li></ul> <h3 id="运算符重载"><a href="#运算符重载" aria-hidden="true" class="header-anchor">#</a> 运算符重载</h3> <p>在类内部声明被重载的运算符，可以使用运算符进行操作类对象。<br> <strong><code>B operator+(B &amp;b1,B &amp;b2){ ... return B b;}&lt;br/&gt;</code></strong><br>
在类内部声明一下这个运算符一样的函数，然后调用的时候就可直接加减了。<br></p> <table><thead><tr><th style="text-align:left">可重载</th> <th style="text-align:center"></th></tr></thead> <tbody><tr><td style="text-align:left">双目算术运算符</td> <td style="text-align:center"><code>+</code>(加)，<code>-</code>(减)，<code>*</code>(乘)，<code>/</code>(除)，<code>%</code>(取模)</td></tr> <tr><td style="text-align:left">关系运算符</td> <td style="text-align:center"><code>==</code>(等于)，<code>!=</code>(不等于)，<code>&lt;</code>(小于)，<code>&gt;</code>(大于)，<code>&lt;=</code>(小于等于)，<code>&gt;=</code>(大于等于)</td></tr> <tr><td style="text-align:left">逻辑运算符</td> <td style="text-align:center"><code>｜｜</code>(逻辑或)，<code>&amp;&amp;</code>(逻辑与)，<code>!</code>(逻辑非)</td></tr> <tr><td style="text-align:left">单目运算符</td> <td style="text-align:center"><code>+</code>(正)，<code>-</code>(负)，<code>*</code>(指针)，<code>&amp;</code>(取地址)</td></tr> <tr><td style="text-align:left">自增自减运算符</td> <td style="text-align:center"><code>++</code>(自增)，<code>--</code>(自减)</td></tr> <tr><td style="text-align:left">位运算符</td> <td style="text-align:center"><code>｜</code>(按位或)，<code>&amp;</code>(按位与)，<code>~</code>(按位取反)，<code>^</code>(按位异或),，<code>&lt;&lt;</code>(左移)，<code>&gt;&gt;</code>(右移)</td></tr> <tr><td style="text-align:left">赋值运算符</td> <td style="text-align:center"><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code> , <code>% =</code>, <code>&amp;=</code>, <code>｜=</code>,<code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code></td></tr> <tr><td style="text-align:left">空间申请与释放</td> <td style="text-align:center"><code>new</code>, <code>delete</code>, <code>new[ ]</code> , <code>delete[]</code></td></tr> <tr><td style="text-align:left">其他运算符</td> <td style="text-align:center"><code>()</code>(函数调用)，<code>-&gt;</code>(成员访问)，<code>,</code>(逗号)，<code>[]</code>(下标)</td></tr> <tr><td style="text-align:left">不可重载</td> <td style="text-align:center"></td></tr> <tr><td style="text-align:left"><code>.</code></td> <td style="text-align:center">成员访问运算符</td></tr> <tr><td style="text-align:left"><code>.*</code>, <code>-&gt;*</code></td> <td style="text-align:center">成员指针访问运算符</td></tr> <tr><td style="text-align:left"><code>::</code></td> <td style="text-align:center">域运算符</td></tr> <tr><td style="text-align:left"><code>sizeof</code></td> <td style="text-align:center">长度运算符</td></tr> <tr><td style="text-align:left"><code>?:</code></td> <td style="text-align:center">条件运算符</td></tr> <tr><td style="text-align:left"><code>#</code></td> <td style="text-align:center">预处理符号</td></tr></tbody></table> <p>-----from 菜鸟<br>
原则:</p> <ul><li>运算重载符不可以改变语法结构。</li> <li>运算重载符不可以改变操作数的个数。</li> <li>运算重载符不可以改变优先级。</li> <li>运算重载符不可以改变结合性。</li></ul> <div class="language-c extra-class"><pre class="language-c"><code>留坑
</code></pre></div><h2 id="异常处理"><a href="#异常处理" aria-hidden="true" class="header-anchor">#</a> 异常处理</h2> <p>C++中有了try 和catch<br>
用法和py，java中相似。<br></p> <div class="language-c extra-class"><pre class="language-c"><code>try<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token function">catch</span><span class="token punctuation">(</span> 错误名字 e1 <span class="token punctuation">)</span><span class="token punctuation">{</span>
e1<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;你出错了&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token function">catch</span><span class="token punctuation">(</span>错误 e2<span class="token punctuation">)</span><span class="token punctuation">{</span>
throw <span class="token string">&quot;出错了&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>自己定义一下出了什么错该怎么办，比如e1被打印了出来，e2就没管。<br>自己查一下<a href="http://www.runoob.com/cplusplus/cpp-exceptions-handling.html">错误类型</a>。</p> <h2 id="stl"><a href="#stl" aria-hidden="true" class="header-anchor">#</a> STL</h2> <p><a href="http://c.biancheng.net/stl/">C语言中文网的STL</a>(多到我不想整理不会的就去查把)我随意整理下<br>
C++ STL中标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：红黑树</p> <h3 id="向量vector"><a href="#向量vector" aria-hidden="true" class="header-anchor">#</a> 向量vector</h3> <p>vector&lt; T &gt; 容器是包含 T 类型元素的序列容器，和 array&lt;T，N&gt; 容器相似，不同的是 vector&lt; T &gt; 容器的大小可以自动增长，从而可以包含任意数量的元素；因此类型参数 T 不再需要模板参数 N。只要元素个数超出 vector 当前容量，就会自动分配更多的空间。只能在容器尾部高效地删除或添加元素。
线性排序，可以下标访问
<strong><code>#include &lt;vector&gt;</code></strong></p> <ul><li><strong><code>vector&lt;DataType&gt;Name(MaxSize,defaultValue);</code></strong> <ul><li>定义一个vector</li></ul></li> <li>x=<strong><code>Name[i];</code><strong>或</strong><code>Name.at(i)</code></strong> <ul><li>取出了第i个元素</li></ul></li> <li><strong><code>Name.push_back(i);</code></strong> <ul><li>在数组的最后添加一个数据</li></ul></li> <li><strong><code>Name.pop_back();</code></strong> <ul><li>去掉数组的最后一个数据</li></ul></li> <li><strong><code>Name.begin/end</code></strong> <ul><li>得到数组头/尾的指针</li></ul></li> <li><strong><code>Name.front/back</code></strong> <ul><li>得到数组头/尾的- 引用</li></ul></li> <li><strong><code>Name.size()</code></strong> <ul><li>得到数组的长度</li></ul></li> <li><strong><code>Name.clear()</code></strong> <ul><li>清空当前的vector</li></ul></li> <li><strong><code>Name.empty()</code></strong> <ul><li>是ture否false</li></ul></li></ul> <h3 id="队列queue"><a href="#队列queue" aria-hidden="true" class="header-anchor">#</a> 队列queue</h3> <p><strong><code>#include&lt;queue&gt;</code></strong><br> <strong>先进先出队列 &lt; queue &gt;</strong><br>
定义<code>queue&lt;Type&gt; M</code><br></p> <ul><li>查看是否为空队列 <strong><code>M.empty()</code></strong> 是的话返回1，不是返回0;</li> <li>从已有元素后面增加元素 <strong><code>M.push(x)</code></strong></li> <li>输出现有元素的个数 <strong><code>M.size()</code></strong></li> <li>清除队顶元素 <strong><code>M.pop()</code></strong> ,同样它不返回值</li> <li>获取队顶元素 <strong><code>M.front()</code></strong></li> <li>获取队尾元素 <strong><code>M.back()</code></strong></li></ul> <p><strong>优先级队列 &lt; queue &gt;</strong> <a href="https://blog.csdn.net/xiaoquantouer/article/details/52015928">这个挺详细的</a><br>
定义的时候要决定优先值<br> <code>priority_queue&lt; int &gt;Q;</code>默认优先输出大的数据(整数)，可以自己定义<br>
优先输出小数据 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; p;</code><br>
自己重载例子<br></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>
	<span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span>
		<span class="token function">x</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">cmp</span><span class="token punctuation">{</span>
	bool <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Node a<span class="token punctuation">,</span> Node b<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x <span class="token operator">==</span> b<span class="token punctuation">.</span>x<span class="token punctuation">)</span>	<span class="token keyword">return</span> a<span class="token punctuation">.</span>y<span class="token operator">&gt;</span>b<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
		<span class="token keyword">return</span> a<span class="token punctuation">.</span>x<span class="token operator">&gt;</span>b<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	priority_queue<span class="token operator">&lt;</span>Node<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span><span class="token punctuation">,</span> cmp<span class="token operator">&gt;</span>p<span class="token punctuation">;</span>
</code></pre></div><ul><li><strong><code>Q.empty()</code></strong> 判断队列是否为空返回ture表示空返回false表示空 bool</li> <li><strong><code>Q.top()</code></strong> 返回顶端元素的值元素还在队列里</li> <li><strong><code>Q.pop()</code></strong> 删除顶端元素 void</li> <li><strong><code>Q.push(V)</code></strong> 把long long型的数V加入到队列里它会制动条件V的位置void</li> <li><strong><code>Q.size()</code></strong> 返回队列里元素个数 unsigned int</li></ul> <p><strong>双端队列</strong></p> <ul><li><strong><code>deque&lt;int&gt;c</code></strong></li> <li><strong><code>c.pop_back()</code></strong>      删除最后一个数据。</li> <li><strong><code>c.pop_front()</code></strong>      删除头部数据。</li> <li><strong><code>c.push_back(elem)</code></strong>  在尾部加入一个数据。</li> <li><strong><code>c.push_front(elem)</code></strong> 在头部插入一个数据。</li> <li><strong><code>c.clear()</code></strong>          移除容器中所有数据。</li> <li><strong><code>c.front()</code></strong>          传回地一个数据。</li> <li><strong><code>c.back()</code></strong>          传回最后一个数据，不检查这个数据是否存在。</li> <li><strong><code>c.size()</code></strong>           返回容器中实际数据的个数。</li> <li><strong><code>c.empty()</code></strong>         判断容器是否为空。</li> <li><strong><code>c[i]</code></strong> 等同于 <strong><code>c.at(i)</code></strong>;</li></ul> <h3 id="链表list"><a href="#链表list" aria-hidden="true" class="header-anchor">#</a> 链表list</h3> <p>由节点组成的双向链表，每个结点包含着一个元素
<strong><code>list&lt;int&gt; list1(1,2,3)</code></strong></p> <ul><li><strong><code>list.front()</code></strong> <ul><li>返回第一个元素的引用</li> <li>int nRet =list1.front()// nRet = 1</li></ul></li> <li><strong><code>list.back()</code></strong> <ul><li>返回最后一元素的引用</li> <li>int nRet =list1.back()// nRet = 3</li></ul></li> <li><strong><code>list.push_back(x)</code></strong> <ul><li>增加一元素到链表尾</li> <li>list1.push_back(4)//list1(1,2,3,4)</li></ul></li> <li><strong><code>list.push_front(x)</code></strong> <ul><li>增加一元素到链表头</li> <li>list1.push_front(4)//list1(4,1,2,3)</li></ul></li> <li><strong><code>list.pop_back()</code></strong> <ul><li>删除链表尾的一个元素</li> <li>list1.pop_back()//list1(1,2)</li></ul></li> <li><strong><code>list.pop_front()</code></strong> <ul><li>删除链表头的一元素</li> <li>list1.pop_front()//list1(2,3)</li></ul></li> <li><strong><code>list.clear()</code></strong> <ul><li>删除所有元素</li> <li>list1.clear();// list1空了,list1.size()=0</li></ul></li> <li><strong><code>list.sort()</code></strong> <ul><li>对链表排序，默认升序(可自定义回调函数)</li> <li>定义回调函数</li></ul></li> <li><strong><code>list.insert(指针,[几次],元素)</code></strong> <ul><li>在指定位置插入一个或多个元素</li> <li>list1.insert(++list1.begin(),9);  // list1(1,9,2,3);</li> <li>list1.insert(list1.begin(),2,9);  // list1(9,9,1,2,3);</li></ul></li> <li><strong><code>list.swap()</code></strong> <ul><li>交换两个链表(两个重载)</li> <li>list1.swap(list2);//list1（1，2，3） list2（4，5，6）-&gt;list1（4，5，6） list2（1，2，3）</li></ul></li> <li><strong><code>list1.unique()</code></strong> <ul><li>删除相邻重复元素L1(1,1,4,3,5,1)-&gt;L1(1,4,3,5,1)</li></ul></li> <li><strong><code>merge()</code></strong> <ul><li>合并两个有序链表并使之有序</li> <li>升序list1.merge(list2);-&gt;list1(1,2,3,4,5,6) list2现为空</li> <li>降序list1.merge(list2, greater&lt; int &gt;()); //list1(6,5,4,3,2,1) list2现为空</li></ul></li> <li><strong><code>list.reverse()</code></strong> <ul><li>反转链表list1（1，2，3）-&gt;list1(3,2,1)</li></ul></li> <li><strong><code>list1.remove(4)</code></strong> <ul><li>删除链表中匹配值的元素(匹配元素全部删除4)</li></ul></li> <li><strong><code>bool bRet =L1.empty();</code></strong> <ul><li>判断是否链表为空true/false</li></ul></li> <li><strong><code>rbegin()</code></strong> <ul><li>返回链表最后一元素的后向指针(reverse_iteratoror const)list&lt; int&gt;::reverse_iterator it = list1.rbegin();  //*it = 3</li></ul></li> <li><strong><code>rend()</code></strong> <ul><li>返回链表第一元素的下一位置的后向指针list&lt; int&gt;::reverse_iteratorit = list1.rend(); // *(--riter) =</li></ul></li></ul> <h3 id="元组tuple"><a href="#元组tuple" aria-hidden="true" class="header-anchor">#</a> 元组tuple</h3> <h3 id="集合set"><a href="#集合set" aria-hidden="true" class="header-anchor">#</a> 集合set</h3> <p>由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序 &lt; set &gt;
元素不能重复,貌似看到了一个<a href="https://blog.csdn.net/changjiale110/article/details/79108447">原理解析</a>有兴趣的传送过去看看<br>
set&lt; type &gt;: 以less&lt; &gt;为排序法则的set<br>
set&lt; type,op &gt;: 以op为排序法则的set<br>
ps:我也不知道啥意思，不深究了，拿来即用碰到在查就行<br></p> <h3 id="映射map"><a href="#映射map" aria-hidden="true" class="header-anchor">#</a> 映射map</h3> <p>根据key值快速查找记录，查找的复杂度基本是Log(N)，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次
<code>map&lt;int, string&gt; m;</code>定义了键是整数值是字符串的一个字典
插入</p> <ul><li><code>m.insert(pair&lt;int, string&gt;(1, &quot;s1&quot;));</code></li> <li><code>m.insert(map&lt;int, string&gt;::value_type (2, &quot;student_two&quot;));</code>//和上面的插入有啥不一样</li> <li><code>m[3] = &quot;student_three&quot;;</code>//字符串也可以这样取</li></ul> <div class="warning custom-block"><p class="custom-block-title">WARNING</p> <p>当map中有这个关键字时，insert插入不了，但是用数组方式可以覆盖以前该关键字对应的值</p></div> <p>迭代</p> <ul><li><code>for(iter = m=.begin(); iter != m=.end(); iter++){...}</code></li> <li><code>map.size()</code>
查找</li> <li><code>iter = mapStudent.find(1);</code> <ul><li><code>iter-&gt;second</code> 通过map对象的方法获取的iterator数据类型是一个std::pair对象，包括两个数据 <code>iterator-&gt;first</code> 和 <code>iterator-&gt;second</code> 分别代表关键字和存储的数据。
交换和排序</li></ul></li> <li>map中的swap不是一个容器中的元素交换，而是两个容器所有元素的交换。</li> <li>map中的元素是自动按Key升序排序，所以不能对map用sort函数；
函数</li> <li><code>begin()</code> 返回指向map头部的迭代器</li> <li><code>clear()</code>删除所有元素</li> <li><code>count()</code> 返回指定元素出现的次数</li> <li><code>empty()</code> 如果map为空则返回true</li> <li><code>end()</code>   返回指向map末尾的迭代器</li> <li><code>erase()</code>         删除一个元素</li> <li><code>find()</code>          查找一个元素</li> <li><code>size()</code>          返回map中元素的个数</li> <li><code>swap()</code>           交换两个map</li> <li><code>max_size()</code>      返回可以容纳的最大元素个数</li></ul> <h3 id="栈stack"><a href="#栈stack" aria-hidden="true" class="header-anchor">#</a> 栈stack</h3> <p>后进先出的值的排列 &lt; stack &gt;</p> <p><code>stack&lt;int&gt; s;</code></p> <ul><li><strong><code>s.push(x);</code></strong> 入栈</li> <li><strong><code>s.pop();</code></strong> 出栈</li></ul> <div class="warning custom-block"><p class="custom-block-title">WARNING</p> <p>注意，出栈操作只是删除栈顶元素，并不返回该元素。</p></div> <ul><li><strong><code>s.top()</code></strong> 返回栈顶</li> <li><strong><code>s.empty()</code></strong> 当栈空时，返回true。</li> <li><strong><code>s.size()</code></strong> 访问栈中的元素个数</li></ul> <h3 id="字符串string"><a href="#字符串string" aria-hidden="true" class="header-anchor">#</a> 字符串string</h3> <p>众所周知C++处理字符串有点难过。不做最好用的库就是<code>#include &lt;string&gt;</code>,别带h。<br> <strong>声明:</strong><br> <code>string s;string s=&quot;abcd&quot;;</code>或者<code>string s=&quot;a b cd&quot;;string s(&quot;xtsy&quot;)</code>这样。（空格也会被算进去的<br> <strong>输入:</strong><br> <code>cin&gt;&gt;s;</code>            不能读入空格，以空格、制表符、回车符作为结束标志<br> <code>getline(cin,s);</code>   可以读入空格和制表符，以回车符作为结束标志<br> <strong>长度:</strong><br> <code>int len=s.size();</code>    或者<code>int len=s.length();</code>返回一个int<br> <code>bool=s.empty();</code>        当前字符串是否为空<br> <strong>下标字符:</strong><br> <code>s[i]</code>或 <code>char c=s.at(i)</code>返回的是一个char。<br> <strong>转换:</strong><br> <code>s=str;string</code>类型=char数组;重载了运算符，直接就能转换。<br> <code>#include &quot;string.h&quot;</code><br> <code>strcpy(str,s.c_str());</code><br> <strong>比较:</strong><br> <code>if(s1&lt;s2);或s1.compare(s2);</code><br>
真返回1假返回-1<br> <strong>拼接:</strong><br> <code>s1=s1+s2;</code>或<code>s1.append(s2);</code><br> <strong>查找:</strong><br> <code>s.find(s1)</code>    查找s中第一次出现s1的位置，并返回（包括0）<br> <code>s.rfind(s1)</code>   查找s中最后次出现s1的位置，并返回（包括0）<br> <code>s.find_first_of(s1)</code>     查找在s1中任意一个字符在s中第一次出现的位置，并返回（包括0）<br> <code>s.find_last_of(s1)</code>    查找在s1中任意一个字符在s中最后一次出现的位置，并返回（包括0）<br> <code>s.find_first_not_of(s1)</code>      查找s中第一个不属于s1中的字符的位置，并返回（包括0）<br> <code>s.find_last_not_of(s1)</code>     查找s中最后一个不属于s1中的字符的位置，并返回（包括0）<br></p> <p><strong>插入:</strong><br> <code>s.insert(p,s);</code>在p0位置插入字符串s<br> <code>s.insert(p,s,n);</code>在p0位置插入字符串s的前n个字符<br> <code>s.insert(p,s);</code>在p0位置插入字符串s<br> <code>s.insert(p,s,pos,n);</code>在p0位置插入字符串s从pos下标(整数)开始的连续n个字符<br> <code>s.insert(p, n,c);</code>在p0处插入n个字符c<br></p> <p><strong>截取:</strong><br> <code>s=s.substr(pos, n)</code>  截取s中从pos开始（包括0）的n个字符的子串，并返回<br> <code>s=s.substr(pos)</code>      截取s中从从pos开始（包括0）到末尾的所有字符的子串，并返回<br> <strong>反转:</strong><br> <code>#include&lt;algorithm&gt;</code><br> <code>reverse(s.begin(),s.end());</code><br></p> <div class="warning custom-block"><p class="custom-block-title">WARNING</p> <p>反转不返回会直接对原来的字符串进行操作</p></div> <p><strong>替换:</strong><br> <code>s.replace(pos, n, s1)</code>     用s1替换s中从pos开始（包括0）的n个字符的子串<br> <code>#include&lt;algorithm&gt;</code><br> <code>replace(str.begin(),str.end(),'a','b');</code>从开始到结尾a替换成b，也是对原串操作，而且只能对单个字符进行操作<br></p> <h2 id="参考资料列表"><a href="#参考资料列表" aria-hidden="true" class="header-anchor">#</a> 参考资料列表</h2> <p>整理的时候想整理成一个来着，发现太长了就分成了俩，于是参考资料列表也在c中。</p></div> <!----> <!----> <!----> <div class="page-edit" data-v-cdcae5a4><!----> <div class="last-updated" data-v-cdcae5a4><span class="prefix" data-v-cdcae5a4>Last Updated: </span> <span class="time" data-v-cdcae5a4>11/8/2019, 7:50:25 AM</span></div></div> <div class="page-nav" data-v-cdcae5a4><p class="inner" data-v-cdcae5a4><span class="prev" data-v-cdcae5a4>
        ←
        <a href="/blog/back/C和Cpp/C.html" class="prev" data-v-cdcae5a4>
          C基础
        </a></span> <span class="next" data-v-cdcae5a4><a href="/blog/back/C和Cpp/数据结构1.html" data-v-cdcae5a4>
          C++数据结构(一)
        </a>
        →
      </span></p></div> </div> <div class="valine-wrapper" data-v-63f18ac0><div id="valine" style="display:;" data-v-63f18ac0></div></div> <!----> <!----> <div class="back-to-ceiling" style="right:1rem;bottom:3rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;background-color:rgba(231, 234, 241,.5);display:none;" data-v-41016a8b data-v-41016a8b><i class="iconfont reco-up" data-v-41016a8b></i></div></div></div></div>
    <script src="/assets/js/app.64171550.js" defer></script><script src="/assets/js/41.16bfab2f.js" defer></script>
  </body>
</html>
