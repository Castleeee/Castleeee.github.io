<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C基础 | 会走路的三百块</title>
    <meta name="description" content="年轻人的博客">
    <link rel="icon" href="/logo1.ico" type="image/x-icon">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.d22626bb.css" as="style"><link rel="preload" href="/assets/js/app.64171550.js" as="script"><link rel="preload" href="/assets/js/23.1b0b2120.js" as="script"><link rel="preload" href="/assets/js/38.34e99c36.js" as="script"><link rel="prefetch" href="/assets/js/10.f30e4bf5.js"><link rel="prefetch" href="/assets/js/100.14a8b555.js"><link rel="prefetch" href="/assets/js/101.9e257240.js"><link rel="prefetch" href="/assets/js/11.c050169c.js"><link rel="prefetch" href="/assets/js/12.9abd0678.js"><link rel="prefetch" href="/assets/js/13.ca763ee5.js"><link rel="prefetch" href="/assets/js/14.69f05fca.js"><link rel="prefetch" href="/assets/js/15.db5225be.js"><link rel="prefetch" href="/assets/js/16.c6de58f6.js"><link rel="prefetch" href="/assets/js/17.a33727a2.js"><link rel="prefetch" href="/assets/js/18.78f0824a.js"><link rel="prefetch" href="/assets/js/19.20a4f3cf.js"><link rel="prefetch" href="/assets/js/20.15fb9aec.js"><link rel="prefetch" href="/assets/js/21.c2410e24.js"><link rel="prefetch" href="/assets/js/22.6423d49a.js"><link rel="prefetch" href="/assets/js/24.93132bac.js"><link rel="prefetch" href="/assets/js/25.a334198a.js"><link rel="prefetch" href="/assets/js/26.c1c7aaa3.js"><link rel="prefetch" href="/assets/js/27.2c86a0cd.js"><link rel="prefetch" href="/assets/js/28.a9d5d0ae.js"><link rel="prefetch" href="/assets/js/29.82f2e489.js"><link rel="prefetch" href="/assets/js/3.465cd447.js"><link rel="prefetch" href="/assets/js/30.d0c8250c.js"><link rel="prefetch" href="/assets/js/31.e6286844.js"><link rel="prefetch" href="/assets/js/32.116769da.js"><link rel="prefetch" href="/assets/js/33.38e22b91.js"><link rel="prefetch" href="/assets/js/34.21d15ece.js"><link rel="prefetch" href="/assets/js/35.53517849.js"><link rel="prefetch" href="/assets/js/36.9b848dcf.js"><link rel="prefetch" href="/assets/js/37.bf3574bb.js"><link rel="prefetch" href="/assets/js/39.10a54121.js"><link rel="prefetch" href="/assets/js/4.9d750d27.js"><link rel="prefetch" href="/assets/js/40.0ead9dc2.js"><link rel="prefetch" href="/assets/js/41.16bfab2f.js"><link rel="prefetch" href="/assets/js/42.b0388f8b.js"><link rel="prefetch" href="/assets/js/43.1d51bbcb.js"><link rel="prefetch" href="/assets/js/44.9e15a8ac.js"><link rel="prefetch" href="/assets/js/45.c9a7ee30.js"><link rel="prefetch" href="/assets/js/46.0821d6b3.js"><link rel="prefetch" href="/assets/js/47.fdd4b2c4.js"><link rel="prefetch" href="/assets/js/48.c86a3241.js"><link rel="prefetch" href="/assets/js/49.29d7cdaf.js"><link rel="prefetch" href="/assets/js/5.b5540d72.js"><link rel="prefetch" href="/assets/js/50.88cae993.js"><link rel="prefetch" href="/assets/js/51.39b0672d.js"><link rel="prefetch" href="/assets/js/52.47b9c89c.js"><link rel="prefetch" href="/assets/js/53.561866dc.js"><link rel="prefetch" href="/assets/js/54.44ad8aef.js"><link rel="prefetch" href="/assets/js/55.999cd3f5.js"><link rel="prefetch" href="/assets/js/56.0fc25a14.js"><link rel="prefetch" href="/assets/js/57.fbeec51d.js"><link rel="prefetch" href="/assets/js/58.c2c3e960.js"><link rel="prefetch" href="/assets/js/59.388b8a2f.js"><link rel="prefetch" href="/assets/js/6.9305fa77.js"><link rel="prefetch" href="/assets/js/60.3bab7106.js"><link rel="prefetch" href="/assets/js/61.fab74e1f.js"><link rel="prefetch" href="/assets/js/62.b8451d9d.js"><link rel="prefetch" href="/assets/js/63.1ea19cc7.js"><link rel="prefetch" href="/assets/js/64.21f37b67.js"><link rel="prefetch" href="/assets/js/65.79da4678.js"><link rel="prefetch" href="/assets/js/66.2276f1ea.js"><link rel="prefetch" href="/assets/js/67.cf3e97e4.js"><link rel="prefetch" href="/assets/js/68.3b9433a6.js"><link rel="prefetch" href="/assets/js/69.a6723b19.js"><link rel="prefetch" href="/assets/js/7.8235c05c.js"><link rel="prefetch" href="/assets/js/70.eff0cc02.js"><link rel="prefetch" href="/assets/js/71.577ad016.js"><link rel="prefetch" href="/assets/js/72.ee1b8084.js"><link rel="prefetch" href="/assets/js/73.ce23853b.js"><link rel="prefetch" href="/assets/js/74.e51d0dc7.js"><link rel="prefetch" href="/assets/js/75.3fbf6e41.js"><link rel="prefetch" href="/assets/js/76.1ad79723.js"><link rel="prefetch" href="/assets/js/77.05aaa2f4.js"><link rel="prefetch" href="/assets/js/78.9e4bf317.js"><link rel="prefetch" href="/assets/js/79.028f9c41.js"><link rel="prefetch" href="/assets/js/8.a4265244.js"><link rel="prefetch" href="/assets/js/80.a83e9fee.js"><link rel="prefetch" href="/assets/js/81.e20ef630.js"><link rel="prefetch" href="/assets/js/82.0a2c28d1.js"><link rel="prefetch" href="/assets/js/83.84f22d3a.js"><link rel="prefetch" href="/assets/js/84.8c0c443d.js"><link rel="prefetch" href="/assets/js/85.1473a2e2.js"><link rel="prefetch" href="/assets/js/86.4683653f.js"><link rel="prefetch" href="/assets/js/87.9507aa61.js"><link rel="prefetch" href="/assets/js/88.77ce595e.js"><link rel="prefetch" href="/assets/js/89.d25806a8.js"><link rel="prefetch" href="/assets/js/9.56b90d44.js"><link rel="prefetch" href="/assets/js/90.231b245f.js"><link rel="prefetch" href="/assets/js/91.cb1ec410.js"><link rel="prefetch" href="/assets/js/92.10cedbd9.js"><link rel="prefetch" href="/assets/js/93.575cc043.js"><link rel="prefetch" href="/assets/js/94.9233e13a.js"><link rel="prefetch" href="/assets/js/95.fafa9bc4.js"><link rel="prefetch" href="/assets/js/96.8b941223.js"><link rel="prefetch" href="/assets/js/97.49080105.js"><link rel="prefetch" href="/assets/js/98.82d1cc72.js"><link rel="prefetch" href="/assets/js/99.d78b0b9a.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.0cd5f832.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d22626bb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div><header id="navbarWrapper" class="navbar"><div class="sidebar-button"><i class="iconfont reco-menu"></i></div> <a href="/" class="home-link router-link-active"><img src="/head3.png" alt="会走路的三百块" class="logo"> <span class="site-name">会走路的三百块</span></a> <div class="links" style="max-width:nullpx;"><div class="side-search-wrapper"><div class="search-box" data-v-1b2e3b29><input aria-label="Search" autocomplete="off" spellcheck="false" value="" data-v-1b2e3b29> <i class="iconfont reco-search" data-v-1b2e3b29></i> <!----></div></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/backEnd.html" class="nav-link"><i class="iconfont undefined"></i>
  后端
</a></li><li class="dropdown-item"><!----> <a href="/categories/frontEnd.html" class="nav-link"><i class="iconfont undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/categories/bigData.html" class="nav-link"><i class="iconfont undefined"></i>
  大数据
</a></li><li class="dropdown-item"><!----> <a href="/categories/Distributed.html" class="nav-link"><i class="iconfont undefined"></i>
  分布式
</a></li><li class="dropdown-item"><!----> <a href="/categories/life.html" class="nav-link"><i class="iconfont undefined"></i>
  日记
</a></li></ul></div></div><div class="nav-item"><a href="/tags/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tags
</a></div><div class="nav-item"><a href="/categories/article.html" class="nav-link"><i class="iconfont reco-up"></i>
  Library
</a></div><div class="nav-item"><a href="/timeLine/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/about.html" class="nav-link"><i class="iconfont reco-account"></i>
  about me
</a></div><div class="nav-item"><a href="https://www.jianshu.com/u/04777e91e2ef" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-jianshu"></i>
  简书
  </a></div><div class="nav-item"><a href="https://github.com/Castleeee" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  </a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><div class="side-search-wrapper"><div class="search-box" data-v-1b2e3b29><input aria-label="Search" autocomplete="off" spellcheck="false" value="" data-v-1b2e3b29> <i class="iconfont reco-search" data-v-1b2e3b29></i> <!----></div></div> <nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/backEnd.html" class="nav-link"><i class="iconfont undefined"></i>
  后端
</a></li><li class="dropdown-item"><!----> <a href="/categories/frontEnd.html" class="nav-link"><i class="iconfont undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/categories/bigData.html" class="nav-link"><i class="iconfont undefined"></i>
  大数据
</a></li><li class="dropdown-item"><!----> <a href="/categories/Distributed.html" class="nav-link"><i class="iconfont undefined"></i>
  分布式
</a></li><li class="dropdown-item"><!----> <a href="/categories/life.html" class="nav-link"><i class="iconfont undefined"></i>
  日记
</a></li></ul></div></div><div class="nav-item"><a href="/tags/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tags
</a></div><div class="nav-item"><a href="/categories/article.html" class="nav-link"><i class="iconfont reco-up"></i>
  Library
</a></div><div class="nav-item"><a href="/timeLine/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/about.html" class="nav-link"><i class="iconfont reco-account"></i>
  about me
</a></div><div class="nav-item"><a href="https://www.jianshu.com/u/04777e91e2ef" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-jianshu"></i>
  简书
  </a></div><div class="nav-item"><a href="https://github.com/Castleeee" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  </a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><!----></p> <ul class="sidebar-group-items"><li><a href="/blog/back/C%E5%92%8CCpp/C.html#变量和类型" class="sidebar-link">变量和类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#整数类型" class="sidebar-link">整数类型</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#浮点数类型" class="sidebar-link">浮点数类型</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#类型定义" class="sidebar-link">类型定义</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#类型转换" class="sidebar-link">类型转换</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#字符-字符串" class="sidebar-link">字符&amp;字符串</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#枚举enum" class="sidebar-link">枚举enum</a></li></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/C.html#常量" class="sidebar-link">常量</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#define" class="sidebar-link">define</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#const" class="sidebar-link">const</a></li></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/C.html#输入输出" class="sidebar-link">输入输出</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#io含树" class="sidebar-link">IO含树</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#占位符" class="sidebar-link">占位符</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#特殊符号" class="sidebar-link">特殊符号</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#运算符" class="sidebar-link">运算符</a></li></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/C.html#分支循环" class="sidebar-link">分支循环</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#if-语句" class="sidebar-link">if 语句</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#for-语句" class="sidebar-link">for 语句</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#while语句" class="sidebar-link">while语句</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#switch语句" class="sidebar-link">switch语句</a></li></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/C.html#含树🌳" class="sidebar-link">含树🌳</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#参数" class="sidebar-link">参数</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#递归" class="sidebar-link">递归</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#闭包和lambda" class="sidebar-link">闭包和Lambda</a></li></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/C.html#变量存储机制" class="sidebar-link">变量存储机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#局部-全局" class="sidebar-link">局部&amp;全局</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#静态static" class="sidebar-link">静态static</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#外部extern" class="sidebar-link">外部extern</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#auto" class="sidebar-link">auto</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#程序堆栈" class="sidebar-link">程序堆栈</a></li></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/C.html#数组list" class="sidebar-link">数组list</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#多维数组的指针" class="sidebar-link">多维数组的指针</a></li></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/C.html#指针" class="sidebar-link">指针</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/C.html#内存管理" class="sidebar-link">内存管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#malloc-free" class="sidebar-link">malloc;free</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#memset-memcopy" class="sidebar-link">memset;memcopy</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#sizeof" class="sidebar-link">sizeof</a></li></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/C.html#结构体" class="sidebar-link">结构体</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#struct" class="sidebar-link">struct</a></li><li class="sidebar-sub-header"><a href="/blog/back/C%E5%92%8CCpp/C.html#typedef" class="sidebar-link">typedef</a></li></ul></li><li><a href="/blog/back/C%E5%92%8CCpp/C.html#参考资料列表包含c-的" class="sidebar-link">参考资料列表包含c++的</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page" data-v-cdcae5a4> <div class="page-title" data-v-cdcae5a4><h1 data-v-cdcae5a4>C基础</h1> <hr data-v-cdcae5a4> <div data-v-2c25cede data-v-cdcae5a4><i class="iconfont reco-account" data-v-2c25cede><span data-v-2c25cede>会走路的三百块</span></i> <i class="iconfont reco-date" data-v-2c25cede><span data-v-2c25cede>2/16/2019</span></i> <!----> <i class="iconfont reco-tag tags" data-v-2c25cede><span class="tag-item" data-v-2c25cede>
      语言基础
    </span><span class="tag-item" data-v-2c25cede>
      后端
    </span><span class="tag-item" data-v-2c25cede>
      C/C++
    </span><span class="tag-item" data-v-2c25cede>
      所有文章
    </span></i></div></div> <div class="content" data-v-cdcae5a4><div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>考研需要c++，回忆一下语言基础。<br>
因为不是专精底层，记录错误和踩到的坑</p></div> <div align="center"><h1><strong>C语言</strong></h1></div> <h2 id="变量和类型"><a href="#变量和类型" aria-hidden="true" class="header-anchor">#</a> 变量和类型</h2> <p>1B=8bit<br>
1kB=1024B<br>
1mB=1024kB<br>
1GB=1024MB<br>
1TB=1024GB<br>
1PB=1024TB<br></p> <ul><li>先定义后使用</li> <li>字母数字下划线,不能数字开头</li></ul> <h3 id="整数类型"><a href="#整数类型" aria-hidden="true" class="header-anchor">#</a> 整数类型</h3> <table><thead><tr><th style="text-align:right">类型</th> <th style="text-align:center">存储大小</th> <th style="text-align:left">值范围</th></tr></thead> <tbody><tr><td style="text-align:right">char</td> <td style="text-align:center">1 字节</td> <td style="text-align:left">-128 到 127 或 0 到 255</td></tr> <tr><td style="text-align:right">unsigned char</td> <td style="text-align:center">1 字节</td> <td style="text-align:left">0 到 255</td></tr> <tr><td style="text-align:right">signed char</td> <td style="text-align:center">1 字节</td> <td style="text-align:left">-128 到 127</td></tr> <tr><td style="text-align:right">int</td> <td style="text-align:center">2 或 4 字节</td> <td style="text-align:left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr> <tr><td style="text-align:right">unsigned int</td> <td style="text-align:center">2 或 4 字节</td> <td style="text-align:left">0 到 65,535 或 0 到 4,294,967,295</td></tr> <tr><td style="text-align:right">short</td> <td style="text-align:center">2 字节</td> <td style="text-align:left">-32,768 到 32,767</td></tr> <tr><td style="text-align:right">unsigned short</td> <td style="text-align:center">2 字节</td> <td style="text-align:left">0 到 65,535</td></tr> <tr><td style="text-align:right">long</td> <td style="text-align:center">4 字节</td> <td style="text-align:left">-2,147,483,648 到 2,147,483,647</td></tr> <tr><td style="text-align:right">unsigned long</td> <td style="text-align:center">4 字节</td> <td style="text-align:left">0 到 4,294,967,295</td></tr></tbody></table> <h3 id="浮点数类型"><a href="#浮点数类型" aria-hidden="true" class="header-anchor">#</a> 浮点数类型</h3> <table><thead><tr><th style="text-align:right">类型</th> <th style="text-align:center">存储大小</th> <th style="text-align:center">值范围</th> <th style="text-align:left">精度</th></tr></thead> <tbody><tr><td style="text-align:right">float</td> <td style="text-align:center">4 字节</td> <td style="text-align:center">1.2E-38 到 3.4E+38</td> <td style="text-align:left">6 位小数</td></tr> <tr><td style="text-align:right">double</td> <td style="text-align:center">8 字节</td> <td style="text-align:center">2.3E-308 到 1.7E+308	15</td> <td style="text-align:left">位小数</td></tr> <tr><td style="text-align:right">long double</td> <td style="text-align:center">16 字节</td> <td style="text-align:center">3.4E-4932 到 1.1E+4932</td> <td style="text-align:left">19 位小数</td></tr></tbody></table> <h3 id="类型定义"><a href="#类型定义" aria-hidden="true" class="header-anchor">#</a> 类型定义</h3> <p>变量是有地址中的一个<code>值</code>和<code>名字</code>构成的.<br>
在定义中不允许连续赋值，如int a=b=c=5;是不合法的。</p> <h3 id="类型转换"><a href="#类型转换" aria-hidden="true" class="header-anchor">#</a> 类型转换</h3> <p><code>(doubel)a</code>;<br>
字符型变量的值实质上是一个8位的整数值，因此取值范围一般是-128～127，char型变量也可以加修饰符unsigned，则unsigned char 型变量的取值范围是0～255(有些机器把char型当做unsighed char型对待， 取值范围总是0～255)。</p> <ul><li>浮点数赋给整型，该浮点数小数被舍去；</li> <li>整数赋给浮点型，数值不变，但是被存储到相应的浮点型变量中；
强制类型转换的时候:<br>
自动类型转换:<strong>char-&gt;int-&gt;double&lt;-char</strong><br>
强制类型转换:<strong>char,short-&gt;unsigned-&gt;long-&gt;double&lt;-float</strong><br>
不能逆序,会有信息损失，分数转成整数就会舍掉小数位,char类型数据转换为int类型数据遵循ASCII码中的对应值<br>
看<a href="https://blog.csdn.net/ce123_zhouwei/article/details/9104681">这里</a><br> <code>int a=5;</code><br> <code>double_a=(double) a;</code>#类型转换不会影响原来的值<br></li></ul> <h3 id="字符-字符串"><a href="#字符-字符串" aria-hidden="true" class="header-anchor">#</a> 字符&amp;字符串</h3> <h4>字符</h4> <p>定义字符用<code>char</code>来定义(实质上是ascii的编码的int)，所占空间和范围见上表，占位符使用<code>%c</code></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">char</span> q<span class="token operator">=</span><span class="token string">'a'</span>
<span class="token keyword">char</span> x<span class="token operator">=</span><span class="token string">'x'</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d,%c&quot;</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>声明一个字符，但是我们用整型输出，就会输出它对应的ASCII码数字了,char只能存储一个字符，它的取值范围是：ASCII码字符 或者 -128~127的整数</p> <div class="danger custom-block"><p class="custom-block-title">WARNING</p> <p>用<code>''</code>单引号，切忌，千万不能用双引号，双引号是来表示字符串的。</p></div> <h4>字符串</h4> <p>c中没有string。c的字符串是以null<code>'/0'</code>结尾的一维字符数组，字符数量会比实际显示的字符数多1，可以简写为<code>char yy[] = &quot;Hello&quot;;</code></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">char</span> xx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">,</span><span class="token string">'y'</span><span class="token punctuation">,</span><span class="token string">'z'</span><span class="token punctuation">,</span><span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> yy<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s,%s&quot;</span><span class="token punctuation">,</span>xx<span class="token punctuation">,</span>yy<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>c基本的几个函数(等后面c++里还会变)</p> <table><thead><tr><th style="text-align:right">序号</th> <th style="text-align:center">函数</th> <th style="text-align:center">目的</th></tr></thead> <tbody><tr><td style="text-align:right">1</td> <td style="text-align:center">strcpy(s1, s2);</td> <td style="text-align:center">复制字符串 s2 到字符串 s1。</td></tr> <tr><td style="text-align:right">2</td> <td style="text-align:center">strcat(s1, s2);</td> <td style="text-align:center">连接字符串 s2 到字符串 s1 的末尾。</td></tr> <tr><td style="text-align:right">3</td> <td style="text-align:center">strlen(s1);</td> <td style="text-align:center">返回字符串 s1 的长度。</td></tr> <tr><td style="text-align:right">4</td> <td style="text-align:center">strcmp(s1, s2);</td> <td style="text-align:center">如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td></tr> <tr><td style="text-align:right">5</td> <td style="text-align:center">strchr(s1, ch);</td> <td style="text-align:center">返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr> <tr><td style="text-align:right">6</td> <td style="text-align:center">strstr(s1, s2);</td> <td style="text-align:center">返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table> <p>----from 菜鸟教程</p> <h3 id="枚举enum"><a href="#枚举enum" aria-hidden="true" class="header-anchor">#</a> 枚举enum</h3> <p>enum 名字 {e1,e2,e3...} e;</p> <p>这样就定义了一个枚举e（也可以先不定义e，后面enum 名字 e），第一个元素e1默认为0，后续元素逐个+1，可以自己定义，如e3=5那么元素变为0，1，5，6...</p> <div class="warning custom-block"><p class="custom-block-title">WARNING</p> <p>枚举被定义int或unsigned int，不连续的枚举无法遍历</p></div> <div class="language-c extra-class"><pre class="language-c"><code>留坑
</code></pre></div><h2 id="常量"><a href="#常量" aria-hidden="true" class="header-anchor">#</a> 常量</h2> <h3 id="define"><a href="#define" aria-hidden="true" class="header-anchor">#</a> define</h3> <p><code>#define X 3</code>定义了X为3，利用宏定义，不能改变，不做计算，不做表达式求解</p> <ul><li>define宏是在预处理阶段展开。</li> <li>define宏没有类型，不做任何类型检查，仅仅是展开</li> <li>define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。</li></ul> <div class="tip custom-block"><p class="custom-block-title">冷知识</p> <p>宏定义不分配内存，变量定义分配内存<br>
比如说C语言标准规定编译器至少支持宏的名字有63个字符（多的话意义不能保证），至少支持同时定义4095个宏，函数形的宏最多可能有127个参数</p></div> <p><a href="https://blog.csdn.net/clever101/article/details/8053510">define的上限</a></p> <h3 id="const"><a href="#const" aria-hidden="true" class="header-anchor">#</a> const</h3> <p><code>const 变量类型 X=3</code>使用const定义了X为3</p> <ul><li>const常量是编译运行阶段使用。</li> <li>const常量有具体的类型，在编译阶段会执行类型检查</li> <li>const常量会在内存中分配(可以是堆中也可以是栈中)
const  可以节省空间，避免不必要的内存分配看代码</li></ul> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">define</span> PI 3.14159 </span><span class="token comment">//常量宏</span>
<span class="token keyword">const</span> doulbe Pi<span class="token operator">=</span><span class="token number">3.14159</span><span class="token punctuation">;</span> <span class="token comment">//此时并未将Pi放入ROM中</span>
<span class="token keyword">double</span> i<span class="token operator">=</span>Pi<span class="token punctuation">;</span> <span class="token comment">//此时为Pi分配内存，以后不再分配！</span>
<span class="token keyword">double</span> I<span class="token operator">=</span>PI<span class="token punctuation">;</span> <span class="token comment">//编译期间进行宏替换，分配内存</span>
<span class="token keyword">double</span> j<span class="token operator">=</span>Pi<span class="token punctuation">;</span> <span class="token comment">//没有内存分配</span>
<span class="token keyword">double</span> J<span class="token operator">=</span>PI<span class="token punctuation">;</span> <span class="token comment">//再进行宏替换，又一次分配内存！</span>
</code></pre></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p> <p>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define定义的常量在内存中有若干个拷贝。
<br>编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。</p></div> <p>一些规则<br></p> <ul><li>有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。</li> <li>在C++ 程序中只使用const常量而不使用宏常量，即const常量完全取代宏常量。</li> <li>需对外公开的常量放在头文件中，不对外公开的常量放在定义文件头部,可以把不同模块的常量集中放在一个公共头文件中</li> <li>如果某一常量与其它常量密切相关，应在定义中包含这种关系，而不应给出一些孤立的值。</li></ul> <div class="danger custom-block"><p class="custom-block-title">WARNING</p> <p>const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的，因为类可以创建多个对象，不同的对象其const数据成员的值可以不同,应该用类中的枚举常量来实现</p></div> <h2 id="输入输出"><a href="#输入输出" aria-hidden="true" class="header-anchor">#</a> 输入输出</h2> <h3 id="io含树"><a href="#io含树" aria-hidden="true" class="header-anchor">#</a> IO含树</h3> <p>scanf和printf<br>
scanf(&quot;占位符1,占位符2&quot;,变量地址1,变量地址2,...);<br>
控制台输入要和这个一样1,2<br>
printf(“格式控制字符串”, 输出表列)<br>
printf和puts两者都属于stdio.h这个头文件，都能输出字符串<br>
puts()在输出字符串时会将'\0'自动转换成'\n'进行输出.</p> <h3 id="占位符"><a href="#占位符" aria-hidden="true" class="header-anchor">#</a> 占位符</h3> <p>格式字符有d,o,x,u,c,s,f,e,g等。</p> <table><thead><tr><th style="text-align:right">类型</th> <th style="text-align:left">作用</th></tr></thead> <tbody><tr><td style="text-align:right">％d      </td> <td style="text-align:left">整型输出</td></tr> <tr><td style="text-align:right">％ld      </td> <td style="text-align:left">长整型输出，</td></tr> <tr><td style="text-align:right">％o      </td> <td style="text-align:left">以八进制数形式输出整数，</td></tr> <tr><td style="text-align:right">％x      </td> <td style="text-align:left">以十六进制数形式输出整数，或输出字符串的地址。</td></tr> <tr><td style="text-align:right">％u      </td> <td style="text-align:left">以十进制数输出unsigned型数据(无符号数)。</td></tr> <tr><td style="text-align:right">％c      </td> <td style="text-align:left">用来输出一个字符，</td></tr> <tr><td style="text-align:right">％s      </td> <td style="text-align:left">用来输出一个字符串，</td></tr> <tr><td style="text-align:right">％f      </td> <td style="text-align:left">用来输出实数，以小数形式输出，默认情况下保留小数点6位。</td></tr> <tr><td style="text-align:right">%.100f      </td> <td style="text-align:left">用来输出实数，保留小数点100位。</td></tr> <tr><td style="text-align:right">％e      </td> <td style="text-align:left">以指数形式输出实数，</td></tr> <tr><td style="text-align:right">％g      </td> <td style="text-align:left">根据大小自动选f格式或e格式，且不输出无意义的零。</td></tr></tbody></table> <div class="warning custom-block"><p class="custom-block-title">WARNING</p> <p>%d与%u有无符号的数值范围，也就是极限的值，不然数值打印出来会有误。</p></div> <h3 id="特殊符号"><a href="#特殊符号" aria-hidden="true" class="header-anchor">#</a> 特殊符号</h3> <p>6个特殊符号</p> <table><thead><tr><th style="text-align:right">符号            </th> <th style="text-align:left">            意义</th> <th style="text-align:left">ascii对应</th></tr></thead> <tbody><tr><td style="text-align:right">            空格            </td> <td style="text-align:left">            ' '            </td> <td style="text-align:left">\u0020</td></tr> <tr><td style="text-align:right">            换页            </td> <td style="text-align:left">            '\f'            </td> <td style="text-align:left"></td></tr> <tr><td style="text-align:right">            换行            </td> <td style="text-align:left">            '\n'            </td> <td style="text-align:left">\u0010</td></tr> <tr><td style="text-align:right">            回车            </td> <td style="text-align:left">            '\r'            </td> <td style="text-align:left">\u0013</td></tr> <tr><td style="text-align:right">            水平制表符            </td> <td style="text-align:left">            '\t'            </td> <td style="text-align:left">\u0009</td></tr> <tr><td style="text-align:right">            垂直制表符            </td> <td style="text-align:left">            '\v'            </td> <td style="text-align:left"></td></tr></tbody></table> <h3 id="运算符"><a href="#运算符" aria-hidden="true" class="header-anchor">#</a> 运算符</h3> <p>常见的我就不放了，注意<code>%</code>是取余数</p> <table><thead><tr><th style="text-align:right">等级</th> <th style="text-align:left">运算符</th></tr></thead> <tbody><tr><td style="text-align:right">1      </td> <td style="text-align:left">      （ ）      </td></tr> <tr><td style="text-align:right">2      </td> <td style="text-align:left">      ！  +（正号）  -（负号）  ++  --      </td></tr> <tr><td style="text-align:right">3      </td> <td style="text-align:left">       *  /  %      </td></tr> <tr><td style="text-align:right">4      </td> <td style="text-align:left">      +（加）  -（减）      </td></tr> <tr><td style="text-align:right">5      </td> <td style="text-align:left">      &lt;  &lt;=  &gt;=  &gt;      </td></tr> <tr><td style="text-align:right">6      </td> <td style="text-align:left">      ==  !=      </td></tr> <tr><td style="text-align:right">7      </td> <td style="text-align:left">      &amp;&amp;      </td></tr> <tr><td style="text-align:right">8      </td> <td style="text-align:left">       **</td></tr> <tr><td style="text-align:right">9      </td> <td style="text-align:left">       ?:      </td></tr> <tr><td style="text-align:right">10      </td> <td style="text-align:left">      =  +=  -= *= /= %=      </td></tr></tbody></table> <div class="warning custom-block"><p class="custom-block-title">WARNING</p> <p>注意：复合运算符中运算符和等号之间是不存在空格的。</p></div> <h2 id="分支循环"><a href="#分支循环" aria-hidden="true" class="header-anchor">#</a> 分支循环</h2> <h3 id="if-语句"><a href="#if-语句" aria-hidden="true" class="header-anchor">#</a> if 语句</h3> <p>分支循环时</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>嵌套if的时候是有域的定义的，注意变量的作用域</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
     <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
             <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre></div><div class="danger custom-block"><p class="custom-block-title">WARNING</p> <p>if和else后面不要加分号</p></div> <h3 id="for-语句"><a href="#for-语句" aria-hidden="true" class="header-anchor">#</a> for 语句</h3> <p>使用for语句应该注意：</p> <ol><li>for循环中的“表达式1. 2. 3”均可可以缺省，但分号(;)不能缺省。</li> <li>省略“表达式1（循环变量赋初值）”，表示不对循环变量赋初始值。如：</li></ol> <div class="language-c extra-class"><pre class="language-c"><code>    <span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;start %d\n&quot;</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li>省略“表达式2(循环条件)”，不做其它处理，循环一直执行（死循环）。如：</li></ol> <div class="language-c extra-class"><pre class="language-c"><code>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
</code></pre></div><ol start="4"><li>省略“表达式3(循环变量增量)”，不做其他处理，循环一直执行（死循环）。如：</li></ol> <div class="language-c extra-class"><pre class="language-c"><code>    <span class="token keyword">int</span> i
    <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
</code></pre></div><ol start="5"><li>表达式1可以是设置循环变量的初值的赋值表达式，也可以是其他表达式。如：</li></ol> <div class="language-c extra-class"><pre class="language-c"><code>    <span class="token keyword">int</span> sun<span class="token punctuation">,</span>moon<span class="token punctuation">;</span>
    sun<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>moon <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>sun<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>moon<span class="token operator">++</span><span class="token punctuation">,</span><span class="token operator">++</span>sun<span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;sun:%d,moon%d&quot;</span><span class="token punctuation">,</span>sun<span class="token punctuation">,</span>moon<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ol start="6"><li>表达式1和表达式3可以是一个简单表达式也可以是多个表达式以逗号分割。如：
<ul><li>同上</li></ul></li> <li>表达式2一般是关系表达式或逻辑表达式，但也可是数值表达式或字符表达式，只要其值非零，就执行循环体。</li></ol> <div class="language-c extra-class"><pre class="language-c"><code>    <span class="token keyword">int</span> sun<span class="token punctuation">,</span>moon<span class="token punctuation">;</span>
    sun<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>moon <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>sun<span class="token operator">&lt;</span><span class="token number">10</span><span class="token operator">&amp;&amp;</span>moon<span class="token punctuation">;</span>moon<span class="token operator">++</span><span class="token punctuation">,</span><span class="token operator">++</span>sun<span class="token punctuation">)</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;sun:%d,moon%d&quot;</span><span class="token punctuation">,</span>sun<span class="token punctuation">,</span>moon<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ol start="8"><li>各表达式中的变量一定要在for循环之前定义。如：</li></ol> <div class="danger custom-block"><p class="custom-block-title">WARNING</p> <p>函数块，if()后面没有分号，直接写{}，else后面也没有分号，直接写{} 可以嵌套</p></div> <h3 id="while语句"><a href="#while语句" aria-hidden="true" class="header-anchor">#</a> while语句</h3> <p>若o不为空则一直执行</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> o<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>do while会先执行一次语句然后在执行while判断。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>strong<span class="token operator">&gt;</span>
</code></pre></div><div class="danger custom-block"><p class="custom-block-title">WARNING</p> <p>do while后面有分号</p></div> <h3 id="switch语句"><a href="#switch语句" aria-hidden="true" class="header-anchor">#</a> switch语句</h3> <div class="language-c extra-class"><pre class="language-c"><code>    <span class="token keyword">int</span> score<span class="token operator">=</span><span class="token number">87</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token number">10</span><span class="token operator">:</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">87</span><span class="token operator">:</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span><span class="token number">87</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">85</span><span class="token operator">:</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span><span class="token number">87</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//不要使用continue;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ol><li>在case后的各常量表达式的值不能相同，否则会出现错误。</li> <li>在case子句后如果没有break;会一直往后执行一直到遇到break;才会跳出switch语句。</li> <li>switch后面的表达式语句只能是整型或者字符类型。</li> <li>在case后，允许有多个语句，可以不用{}括起来。</li> <li>各case和default子句的先后顺序可以变动，而不会影响程序执行结果。</li> <li>default子句可以省略不用</li></ol> <h2 id="含树🌳"><a href="#含树🌳" aria-hidden="true" class="header-anchor">#</a> 含树🌳</h2> <p>就是可复用的代码块<br></p> <blockquote><p>返回值   函数名   (参数){   <br>
     return 返回值     <br>
}<br></p></blockquote> <p>返回值没有就写void,自定义函数尽量放在main函数之前，如果要放在main函数后面的话，需要在main函数之前先声明自定义函数<br>声明格式为：<code>返回值类型 函数名(参数);</code></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;da sha bi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>void 可以有<code>return;</code>其他的函数可以<code>return x;</code>或<code>return (x);</code></p> <h3 id="参数"><a href="#参数" aria-hidden="true" class="header-anchor">#</a> 参数</h3> <h4>形参和实参</h4>
分型参和实参,形参是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数，实参就是实际使用到的参数。
<ul><li>形参只有在被调用时才分配内存单元，在调用结束时会释放所分配的内存单元。</li> <li>实参可以是<code>常量</code> <code>变量</code> <code>表达式</code> <code>函数</code>等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参,应预先用赋值等办法使实参获得确定值。</li> <li>在参数传递时，实参和形参在数量上，类型上，顺序上应严格一致，否则会类型不匹配</li></ul> <h4>不定长参数</h4> <p>不定长参数需要先引入<code>#include &lt;stdarg.h&gt;</code>,函数的第一个参数需要int，指明传进来多少，然后是三个...<br></p> <p>函数体内拿到一个数组，赋值给另一个已知类型的数组，然后清理内存就拿到了。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdarg.h&gt;</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">double</span> x<span class="token operator">=</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">double</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">double</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    va_list valist<span class="token punctuation">;</span><span class="token comment">//定义一个va_list数组</span>
    <span class="token function">va_start</span><span class="token punctuation">(</span>valist<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将数组初始化</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>a<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//循环访问</span>
        <span class="token keyword">double</span> temp<span class="token operator">=</span><span class="token keyword">double</span><span class="token punctuation">(</span><span class="token function">va_arg</span><span class="token punctuation">(</span>valist<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注意这个函数每次调用拿到一个,不使用下标</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%f\n&quot;</span><span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token operator">+=</span>temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">va_end</span><span class="token punctuation">(</span>valist<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token operator">/</span>a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="danger custom-block"><p class="custom-block-title">WARNING</p> <p>实际的可变参数的个数必须比前面强制参数中指定的个数要多，或者不小于。也即后续参数多一点不要紧，但不能少！如果少了则会访问到函数参数以外的堆栈区域，这可能会把程序搞崩掉。前面强制参数中指定的类型和后面实际参数的类型不匹配也有可能造成程序崩溃
<br>va_arg(valist,int);//注意这个函数每次调用拿到一个，无论什么时候，不使用下标(栈)</p></div> <h3 id="递归"><a href="#递归" aria-hidden="true" class="header-anchor">#</a> 递归</h3> <p>定义:在含树体中自己调用自己，执行递归函数将反复调用其自身，每调用一次就进入新的一层。递归需要有边界条件、递归前进段和递归返回段。
经典的斐波那契(Fibonacci)</p> <div class="language-c extra-class"><pre class="language-c"><code>
</code></pre></div><p>还有求阶乘</p> <div class="language-c extra-class"><pre class="language-c"><code></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>递归是非常消耗空间的。每次进行递归都会为函数开辟新的栈空间,容易栈溢出，大部分的递归都可以改写成非递归</p></div> <h3 id="闭包和lambda"><a href="#闭包和lambda" aria-hidden="true" class="header-anchor">#</a> 闭包和Lambda</h3> <p>不支持闭包但是可以通过<code>Lambda</code>和<code>struct</code>嵌套定义来实现。用到再说</p> <h2 id="变量存储机制"><a href="#变量存储机制" aria-hidden="true" class="header-anchor">#</a> 变量存储机制</h2> <h3 id="局部-全局"><a href="#局部-全局" aria-hidden="true" class="header-anchor">#</a> 局部&amp;全局</h3> <p>global和local在一个代码块中新定义的变量在代码块使用结束后就会释放，不能在外面调用。全局变量可以直接调用，如果在代码块中定义了和外面相同名字的变量就优先使用local的变量。</p> <div class="danger custom-block"><p class="custom-block-title">WARNING</p> <p>当局部变量被定义时，系统不会对其初始化，必须自行对其初始化。定义全局变量时，系统会自动对其初始化<br> <code>int-&gt;0</code> <code>char-&gt;'0'</code> <code>float-&gt;0</code> <code>double-&gt;0</code> <code>pointer-&gt;NULL</code></p></div> <h3 id="静态static"><a href="#静态static" aria-hidden="true" class="header-anchor">#</a> 静态static</h3> <p><a href="http://www.runoob.com/w3cnote/cpp-static-usage.html">菜鸟详细解析</a> <br>需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。直接在data和bss段进行定义，生命周期为整个程序<strong>不能在类的声明中定义</strong>（只能声明数据成员）也<strong>不能在头文件中类声明的外部定义</strong></p> <ol><li>静态变量的特性:</li></ol> <ul><li>在修饰变量的时候，static 修饰的静态局部变量<code>只执行初始化一次</code>，而且延长了局部变量的生命周期，直到程序运行<code>结束</code>以后才释放。</li> <li>static 修饰全局变量的时候，这个全局变量只能在<code>本文件中访问</code>，不能在其它文件中访问，即便是 <code>extern</code> 外部声明也<code>不可以</code>。</li> <li>static 修饰一个函数，则这个<code>函数</code>的只能在<code>本文件中调用</code>，不能被其他文件调用。static 修饰的变量存放在全局数据区的<code>静态变量区</code>，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动<code>初始化为 0</code>。</li> <li>不想被释放的时候，可以使用static修饰。比如修饰<code>函数中存放在栈空间的数组</code>。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。</li> <li>考虑到数据安全性（当程序想要使用全局变量的时候应该<code>优先</code>考虑使用 static）。</li></ul> <ol start="2"><li>静态与全局变量：</li></ol> <ul><li>静态变量都在<code>全局数据区分配内存</code>，包括后面将要提到的静态局部变量</li> <li>未经初始化的静态全局变量会被程序<code>自动初始化为0</code>（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为 0）；</li> <li>静态全局变量在声明它的<code>整个文件都是可见</code>的，而在文件<code>之外是不可见</code>的</li> <li>静态全局变量不能被其它文件所用；其它文件中可以定义<code>相同名字</code>的变量，不会发生冲突。</li></ul> <ol start="3"><li>全局变量和全局静态变量的区别:</li></ol> <ul><li>全局变量是不显式用 <code>static</code> 修饰的全局变量，全局变量默认是有<code>外部链接性的</code>，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 <code>extern</code> 全局变量名的声明，就可以使用全局变量。</li> <li>全局静态变量是显式用 <code>static</code> 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 <code>extern</code> 声明也<code>不能使用</code>。</li></ul> <ol start="4"><li>静态局部(internal)变量有以下特点：</li></ol> <ul><li>该变量在<code>全局数据区</code>分配内存；</li> <li>静态局部变量在程序执行到<code>该对象的声明处</code>时被首次<code>初始化</code>，即<code>以后的函数调用不再进行初始化</code>；</li> <li>静态局部变量一般在声明处初始化，如果<code>没有显式初始化</code>，会被程序<code>自动初始化为 0</code>；</li> <li>它始终<code>驻留在全局数据区</code>，直到程序运行结束。但其<strong><code>作用域为局部作用域</code></strong>，当定义它的函数或语句块结束时，其作用域随之结束。
------搬运自菜鸟,转载注明出处</li></ul> <h3 id="外部extern"><a href="#外部extern" aria-hidden="true" class="header-anchor">#</a> 外部extern</h3> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p><code>&lt;&gt;</code>从系统头文件中寻找，没有则报错，<code>&quot;&quot;</code>先从非系统头文件找，没有再找系统头文件，不会报错</p></div> <h4>在单文件中</h4> <p>在同一文件时相当于函数的预声明，告诉编译器这个变量在后面声名<br></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">extern</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">56</span><span class="token punctuation">;</span>
</code></pre></div><h4>在多文件中</h4><br> <p>多文件可以让一个文件引用另一个文件中的变量。在另一个文件中声明一下时extern，同目录(工程)下的文件就可以引用了。
<br>如果用include的话就会让本文件所有的函数变量都可见会不安全。</p> <ol><li>在本文件中声名一个变量<code>int a=5;</code></li> <li>在公共头文件中声明<code>extern int a;</code></li> <li>在其他文件中将声名<code>extern int a;</code>就可以访问到了</li></ol> <div class="warning custom-block"><p class="custom-block-title">WARNING</p> <p>只有当一个变量是一个<code>全局变量</code>时，extern变量才会起作用,局部变量不起作用<br>
不能在其他文件中声明的时候同时赋值extern int a=5;是错误的，必须在原来的文件中重新赋值等等</p></div> <h3 id="auto"><a href="#auto" aria-hidden="true" class="header-anchor">#</a> auto</h3> <p>定义一个变量不指定他的静态还是外部等等就自动默认为auto一般你不指定的就是auto，与之相对的是register寄存器变量这两个不常用。会随机应变auto的出现意味着，当前变量的作用域为当前函数或代码段的局部变量，意味着当前变量会在内存栈上进行分配。</p> <h3 id="程序堆栈"><a href="#程序堆栈" aria-hidden="true" class="header-anchor">#</a> 程序堆栈</h3> <p>一个由C/C++编译的程序占用的内存分为以下几个部分：</p> <ol><li><strong>栈区(stack)</strong> ---由编译器自动分配释放，存放<code>函数的参数值</code>，<code>局部变量的值等</code>。其操作方式类似于数据结构中的<code>栈</code>。</li> <li><strong>堆区(heap)</strong> ---一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式类似于<code>链表</code>。可能用到的关键字如下：new、malloc、delete、free等等</li> <li><strong>全局区(静态区)</strong> ---<code>全局变量</code>和<code>静态变量</code>的存储时放在一块的，<strong>初始化</strong>的全局变量和静态变量在一块区域，<strong>未初始化的</strong>全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后有系统释放。</li> <li><strong>文字常量区</strong> --- <code>常量</code> <code>字符串</code>就是放在这里的。程序结束后由系统释放。</li> <li><strong>程序代码区</strong> --- 存放<code>函数体</code>的二进制。
一般情况下程序存放在Rom或Flash中，运行时需要拷到内存中执行，内存会分别存储不同的信息,<strong>内存中的栈区处于相对较高的地址以地址的增长方向为上的话，栈地址是向下增长的</strong></li></ol> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//main.cpp</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 全局初始化区
<span class="token keyword">char</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span> 全局未初始化区
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token keyword">int</span> b<span class="token punctuation">;</span> 栈
<span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span> 栈
<span class="token keyword">char</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span> 栈
<span class="token keyword">char</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token string">&quot;123456&quot;</span><span class="token punctuation">;</span> <span class="token number">123456</span>\<span class="token number">0</span>在常量区，p3在栈上。
<span class="token keyword">static</span> <span class="token keyword">int</span> c <span class="token operator">=</span><span class="token number">0</span>； 全局（静态）初始化区
p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  堆
p2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  堆
<span class="token punctuation">}</span>
</code></pre></div><p>区别和共同点</p> <ul><li>申请释放
<ul><li>堆：需要程序员自己申请，并指明大小</li> <li>栈：由系统自动分配，例如，声明在函数中一个局部变量int b；系统自动在栈中为b开辟空间</li></ul></li> <li>系统响应
<ul><li>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li> <li>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。
也就是说堆会在申请后还要做一些后续的工作这就会引出申请效率的问题。</li></ul></li> <li>效率
<ul><li>栈:由系统自动分配，速度较快。但程序员是无法控制的。</li> <li>堆:是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。</li></ul></li> <li>内容
<ul><li>栈:在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</li> <li>堆:一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</li></ul></li></ul> <h2 id="数组list"><a href="#数组list" aria-hidden="true" class="header-anchor">#</a> 数组list</h2> <p>数组是自带的,其他的在STL中可以找到，STL里卖弄还有链表树等等啥都有。<br>
数组是一块<code>连续的</code>，<code>大小固定</code>并且里面的数据<code>类型一致</code>的<code>内存</code>空间;<br> <strong>
数据类型 数组名称[长度];<br>
char b[5];<br></strong>
数组初始化有三种形式：<br></p> <ol><li><p>数据类型 数组名称[长度n] = {元素1,元素2…元素n};</p></li> <li><p>数据类型 数组名称[] = {元素1,元素2…元素n};自己会判断有多少个</p></li> <li><p>数据类型 数组名称[长度n]; 数组名称[0] = 元素1; 数组名称[1] = 元素2; 数组名称[n-1] = 元素n;</p></li></ol> <p><br>拿取:数组名称[元素所对应下标];如：初始化一个数组 int arr[3] = {1,2,3}; 那么arr[0]就是元素1。<br></p> <h4>多维数组</h4> <strong>
数据类型 数组名称[行][列];<br>
char b[2][4];<br></strong> <p>其实存储方式还是一维数组的存储方式，地址都是连续的</p> <p>char b[2][4];={1,2,3,4,5,6,7,8};
一般使用for来循环</p> <div class="language-c extra-class"><pre class="language-c"><code>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p> <p>数组的下标均以<code>0</code>开始；初始化的时候，数组内元素的个数<code>不能大于</code>声明的数组长度；如果采用<code>第一种</code>初始化方式，元素个数小于数组的长度时，多余的数组元素初始化为<code>0</code>；在声明数组后没有进行初始化的时候，静态（static）和外部（extern）类型的数组元素初始化元素为0，<code>自动</code>（auto）类型的数组的元素初始化值<code>不确定</code>。</p></div> <p>单独把数组拿出来的时候获得是的数组的<code>首地址</code>，也就是数组的名字就是指向数组的指针
作为参数，返回值</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"># <span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">temp</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">temp</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>作为返回值，函数返回值为一个指定类型的指针，外部需要一个同类型接收的指针，内部声明数组为<code>static</code>，初始化完数组，直接return这个数组的指针(名字)
</p><h4>不定长数组</h4>
参见vector<p></p> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>另外，C 不支持在函数外返回局部变量的地址会报空指针，除非定义局部变量为 static 变量</p></div> <h3 id="多维数组的指针"><a href="#多维数组的指针" aria-hidden="true" class="header-anchor">#</a> 多维数组的指针</h3> <p>多维数组会有维的索引数组，第一次取下标取到的是地址而不是值
</p><div align="center"><img src="/assets/img/arr.20f81446.png"></div><p></p> <h2 id="指针"><a href="#指针" aria-hidden="true" class="header-anchor">#</a> 指针</h2> <p><strong>指针是C语言的灵魂！</strong><br> <strong><code>&amp;</code></strong>符号是取<strong><code>地址</code></strong>，取得地址之后得到的是一个<strong><code>指针</code></strong>类型<br> <strong><code>*</code></strong>符号是<strong><code>指针类型</code></strong>，用来接收一个<strong><code>地址</code></strong>，占位符为<strong><code>%p</code></strong><br>
变量在内存中是有一个<strong><code>地址+值</code></strong>存在的。<br>
所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的<code>十六进制数</code>。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。
一个地址可以被多个指针指向，但是一个指针之可以指一个地址</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span>    <span class="token operator">*</span>ip<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
<span class="token keyword">int</span>    <span class="token operator">*</span>id<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token operator">*</span>dp<span class="token punctuation">;</span>
<span class="token keyword">float</span>  <span class="token operator">*</span>fp<span class="token punctuation">;</span>
<span class="token keyword">char</span>   <span class="token operator">*</span>ch<span class="token punctuation">;</span>
</code></pre></div><div class="danger custom-block"><p class="custom-block-title">WARNING</p> <p>如果定义的时候没想好指针怎么指，那就先赋一个空指针<strong><code>int *p=NULL;</code></strong><br>
在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置</p></div> <p>指针可以进行四则运算，他会指向下一块或者上一块内存区域，比如数组可以用指针来遍历。</p> <div class="language-c extra-class"><pre class="language-c"><code>咕咕咕
</code></pre></div><p>指针可以作为参数和函数返回值。作为参数的时候会直接对外部的变量内存的值进行修改，做返回值就是拿到了该变量的指针，局部变量的指针不能作为返回值，会被释放，要声明一下static</p> <div class="language-c extra-class"><pre class="language-c"><code>咕咕咕
</code></pre></div><p>指针的优先级</p> <table><thead><tr><th style="text-align:center">指针定义</th> <th style="text-align:center">含义</th></tr></thead> <tbody><tr><td style="text-align:center">int p;</td> <td style="text-align:center">这是一个普通的整型变量</td></tr> <tr><td style="text-align:center">int *p;</td> <td style="text-align:center">首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针</td></tr> <tr><td style="text-align:center">int p[3];</td> <td style="text-align:center">首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组</td></tr> <tr><td style="text-align:center">int *p[3];</td> <td style="text-align:center">首先从P 处开始,先与[]结合,因为其优先级比<em>高,所以P 是一个数组,然后再与</em>结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组</td></tr> <tr><td style="text-align:center">int (*p)[3];</td> <td style="text-align:center">首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针</td></tr> <tr><td style="text-align:center">int **p;</td> <td style="text-align:center">首先从P 开始,先与<em>结合,说是P 是一个指针,然后再与</em>结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.</td></tr> <tr><td style="text-align:center">int p(int);</td> <td style="text-align:center">从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据</td></tr> <tr><td style="text-align:center">Int (*p)(int);</td> <td style="text-align:center">从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针</td></tr> <tr><td style="text-align:center">int *(*p(int))[3];</td> <td style="text-align:center">可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的<em>结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与</em>结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</td></tr></tbody></table> <p>-----转自<a href="https://blog.csdn.net/constantin_/article/details/79575638">指针超详细解释</a></p> <div class="danger custom-block"><p class="custom-block-title">WARNING</p> <p>void * 类型表示未确定类型的指针。C/C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。
<a href="http://www.runoob.com/w3cnote/c-void-intro.html">详解</a></p></div> <h2 id="内存管理"><a href="#内存管理" aria-hidden="true" class="header-anchor">#</a> 内存管理</h2> <p>c语言的难点，好在数据结构考试中不那么看重，简单整理一下
需要引入<code>#include &lt;stdlib.h&gt;</code></p> <h3 id="malloc-free"><a href="#malloc-free" aria-hidden="true" class="header-anchor">#</a> malloc;free</h3> <table><thead><tr><th style="text-align:left">函数</th> <th style="text-align:center">作用</th></tr></thead> <tbody><tr><td style="text-align:left">void *calloc(int num, int size);</td> <td style="text-align:center">在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</td></tr> <tr><td style="text-align:left">void free(void *address);</td> <td style="text-align:center">该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</td></tr> <tr><td style="text-align:left">void *malloc(int num);</td> <td style="text-align:center">在<code>堆区</code>分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</td></tr> <tr><td style="text-align:left">void *realloc(void *address, int newsize);</td> <td style="text-align:center">该函数重新分配内存，把内存扩展到 newsize。</td></tr></tbody></table> <div class="danger custom-block"><p class="custom-block-title">WARNING</p> <p>看看就行了，C++中使用new代替了malloc</p></div> <h3 id="memset-memcopy"><a href="#memset-memcopy" aria-hidden="true" class="header-anchor">#</a> memset;memcopy</h3> <p>C语言需要包含头文件string.h；C++需要包含cstring  或  string.h<br></p> <ul><li>void *memset(void *s,int c,size_t n)<br>
作用：将已开辟内存空间 s 的首 n 个字节的值设为值 c（给空间初始化）<br>
最常用的就是把一个数组(未初始化的字符串)初始化</li></ul> <div class="danger custom-block"><p class="custom-block-title">WARNING</p> <p>char * buffer = &quot;Hello world\n&quot;;已初始化的字符串是只读的存在只读存储区，其内容不能被随意更改。</p></div> <div class="language-c extra-class"><pre class="language-c"><code>留坑
</code></pre></div><ul><li>void *memcpy(void *dest, const void *src, size_t n);<br>
用来将src地址处的内容拷贝n个字节的数据至目标地址dest指向的内存中去。函数返回指向dest的指针。</li></ul> <div class="language-c extra-class"><pre class="language-c"><code>留坑
</code></pre></div><div class="danger custom-block"><p class="custom-block-title">WARNING</p> <p>memcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度；例：char a[100],b[50]; memcpy(b, a, sizeof(b));注意如用sizeof(a)，会造成b的内存溢出。<br>
另外：strcpy只能拷贝字符串，它遇到'\0'就结束拷贝；例：char a[100],b[50];strcpy(a,b);如用strcpy(b,a)，要注意a中的字符串长度（第一个‘\0’之前）是否超过50位，如超过，则会造成b的内存溢出。会造成缓冲区溢出，轻者程序崩溃，重者系统会出现问题！！</p></div> <p>----转自<a href="https://blog.csdn.net/scottly1/article/details/16829741">详解</a></p> <h3 id="sizeof"><a href="#sizeof" aria-hidden="true" class="header-anchor">#</a> sizeof</h3> <p>高级用法先不谈，最基本的俩用法
类型：sizeof使用形式：sizeof(type)（sizeof（int））
变量：sizeof使用形式：sizeof(var_name)或sizeof var_name</p> <div class="danger custom-block"><p class="custom-block-title">WARNING</p> <p>sizeof操作符不能用于函数类型，不完全类型或位字段。不完全类型指具有未知存储大小的数据类型，如未知存储大小的数组类型、未知内容的结构或联合类型、void类型等</p></div> <p>Sizeof操作符的结果类型是size_t</p> <p>结果(x64下):</p> <table><thead><tr><th style="text-align:left">结果</th></tr></thead> <tbody><tr><td style="text-align:left">sizeof(int)=4</td></tr> <tr><td style="text-align:left">sizeof(unsigned int)=4</td></tr> <tr><td style="text-align:left">sizeof(short int)=2</td></tr> <tr><td style="text-align:left">sizeof(unsigned short)=2</td></tr> <tr><td style="text-align:left">sizeof(long int)=4</td></tr> <tr><td style="text-align:left">sizeof(unsigned long)=4</td></tr> <tr><td style="text-align:left">sizeof(float)=4</td></tr> <tr><td style="text-align:left">sizeof(double)=8</td></tr> <tr><td style="text-align:left">sizeof(long double)=8</td></tr> <tr><td style="text-align:left">sizeof(char/unsigned char/signed char)=1</td></tr> <tr><td style="text-align:left">sizeof(*ptr)=4</td></tr> <tr><td style="text-align:left">int a[10]，sizeof(a)=40数组结果是数组的总字节数。</td></tr> <tr><td style="text-align:left">联合类型操作数的sizeof是其最大字节成员的字节数</td></tr> <tr><td style="text-align:left">结构类型操作数的sizeof是这种类型对象的总字节数，包括任何铺垫在内；           </td></tr></tbody></table> <h2 id="结构体"><a href="#结构体" aria-hidden="true" class="header-anchor">#</a> 结构体</h2> <p>有点面向对象的意思了，不过还没有对象</p> <h3 id="struct"><a href="#struct" aria-hidden="true" class="header-anchor">#</a> struct</h3> <p><code>struct</code> <strong>name</strong> { <br> <strong>member-list</strong>;<br>
   member-list; <br>
   member-list;  <br>
            ...<br>
} <strong>variable-list</strong> ;<br> <code>struct</code> name n; <br>
以下发言是借用了面向对象的说法<br>
你可以省略掉name，variable-list相当于直接定义了一堆对象而没有类名，也就不能用类名来在定义其他的变量了<br>
你可以省略掉variable-list，但不要落下类名，可以后面手动定义name n;<br>
你也可以把name 通过typedef放在后面typedef struct{} name;让然需要自己生成对象。<br>
访问对象的成员的时候直接用<code>.</code>访问<br>
关于指针：</p> <ul><li>struct name <code>*p</code>;这是定义了一个指针赋值的时候p=&amp;n;</li> <li>取值用<code>p-&gt;m</code>相当于<code>n.m</code></li></ul> <div class="language-c extra-class"><pre class="language-c"><code>
</code></pre></div><h3 id="typedef"><a href="#typedef" aria-hidden="true" class="header-anchor">#</a> typedef</h3> <p><code>typedef</code> 可以给一个东西娶个别名，比如typedef long long ll
这时候使用<code>ll a;=long long a;</code>
一般会用来给结构体娶个新名字</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Books</span>
<span class="token punctuation">{</span>
   <span class="token keyword">char</span>  title<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token keyword">char</span>  author<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token keyword">char</span>  subject<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span>   book_id<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Book<span class="token punctuation">;</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p> <ul><li>typedef 仅限于为类型定义符号名称#define（宏）不仅可以为类型定义别名，也能为数值定义别名</li> <li>typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的</li></ul></div> <p>终于整理完C了！！！</p> <h2 id="参考资料列表包含c-的"><a href="#参考资料列表包含c-的" aria-hidden="true" class="header-anchor">#</a> 参考资料列表包含c++的</h2> <ul><li><a href="https://blog.csdn.net/love_gaohz/article/details/7567856">const与define√</a></li> <li><a href="http://www.runoob.com/cprogramming/c-tutorial.html">菜鸟c语言</a></li> <li><a href="https://www.imooc.com/view/249">慕课c语言</a></li> <li><a href="https://my.oschina.net/jthmath/blog/488462">开源中国元组</a></li> <li><a href="https://blog.csdn.net/a1232345/article/details/44957191">C语言堆栈入门</a></li> <li><a href="https://blog.csdn.net/constantin_/article/details/79575638">超级详细的指针</a></li> <li><a href="https://www.bilibili.com/video/av40959422">bilibili hw-dong</a></li> <li><a href="https://www.cnblogs.com/nzbbody/p/3523064.html">继承过程中构造析构详解</a></li> <li><a href="http://www.runoob.com/cplusplus/cpp-classes-objects.html">菜鸟C++</a></li> <li><a href="https://blog.csdn.net/zuzhiang/article/details/78155112">字符和字符串</a></li> <li><a href="https://blog.csdn.net/ezhou_liukai/article/details/13779091">字符串操作</a></li> <li><a href="https://blog.csdn.net/ezhou_liukai/article/details/13779091 ">字符串</a></li> <li><a href="https://blog.csdn.net/hyg0811/article/details/10956699">STL参考</a></li> <li><a href>1</a></li> <li><a href>1</a></li> <li><a href>1</a></li></ul> <div id="vcomments"></div></div> <!----> <!----> <!----> <div class="page-edit" data-v-cdcae5a4><!----> <div class="last-updated" data-v-cdcae5a4><span class="prefix" data-v-cdcae5a4>Last Updated: </span> <span class="time" data-v-cdcae5a4>11/8/2019, 7:50:25 AM</span></div></div> <div class="page-nav" data-v-cdcae5a4><p class="inner" data-v-cdcae5a4><span class="prev" data-v-cdcae5a4>
        ←
        <a href="/blog/back/C和Cpp/environment.html" class="prev" data-v-cdcae5a4>
          C环境配置
        </a></span> <span class="next" data-v-cdcae5a4><a href="/blog/back/C和Cpp/Cpp.html" data-v-cdcae5a4>
          C++基础
        </a>
        →
      </span></p></div> </div> <div class="valine-wrapper" data-v-63f18ac0><div id="valine" style="display:;" data-v-63f18ac0></div></div> <!----> <!----> <div class="back-to-ceiling" style="right:1rem;bottom:3rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;background-color:rgba(231, 234, 241,.5);display:none;" data-v-41016a8b data-v-41016a8b><i class="iconfont reco-up" data-v-41016a8b></i></div></div></div></div>
    <script src="/assets/js/app.64171550.js" defer></script><script src="/assets/js/23.1b0b2120.js" defer></script><script src="/assets/js/38.34e99c36.js" defer></script>
  </body>
</html>
