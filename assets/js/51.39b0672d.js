(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{465:function(t,e,_){"use strict";_.r(e);var i=_(0),r=Object(i.a)({},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),_("p",[t._v("Go常用命令简介")]),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),t._m(29),t._v(" "),t._m(30),t._v(" "),t._m(31),t._v(" "),t._m(32),t._v(" "),t._m(33),t._v(" "),t._m(34),t._v(" "),t._m(35),t._v(" "),t._m(36),t._v(" "),t._m(37),t._v(" "),_("Valine")],1)},[function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{align:"center"}},[e("h1",[this._v("简介🐋")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{align:"center"}},[this._v("\n类型安全 和 内存安全"),e("br"),this._v("\n以非常直观和极低代价的方案实现 高并发"),e("br"),this._v("\n快速编译,同时解决C语言中头文件太多的问题"),e("br"),this._v("\n为多核计算机提供性能提升的方案"),e("br"),this._v("\n高效的垃圾回收机制"),e("br"),this._v("\nUTF-8编码支持"),e("br")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"乱七八糟交代的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#乱七八糟交代的","aria-hidden":"true"}},[this._v("#")]),this._v(" 乱七八糟交代的")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#命令","aria-hidden":"true"}},[this._v("#")]),this._v(" 命令")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在命令行或终端输入go即可查看所有支持的命令"),e("br")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("go get：获取远程包（需 提前安装 git或hg）")]),t._v(" "),_("li",[t._v("go run：直接运行程序")]),t._v(" "),_("li",[t._v("go build：测试编译，检查是否有编译错误")]),t._v(" "),_("li",[t._v("go fmt：格式化源码（部分IDE在保存时自动调用）")]),t._v(" "),_("li",[t._v("go install：编译包文件并编译整个程序")]),t._v(" "),_("li",[t._v("go test：运行测试文件")]),t._v(" "),_("li",[t._v("go doc：查看文档（CHM手册）")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"关键字保留"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关键字保留","aria-hidden":"true"}},[this._v("#")]),this._v(" 关键字保留")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("// ：单行注释"),e("br"),this._v("\n/* */：多行注释"),e("br")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("a",{attrs:{href:"http://www.runoob.com/go/go-basic-syntax.html"}},[this._v("这里")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"程序结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#程序结构","aria-hidden":"true"}},[this._v("#")]),this._v(" 程序结构")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Go程序是通过 package 来组织的（与python类似）"),e("br"),this._v("\n只有 package 名称为 main 的包可以包含 main 函数"),e("br"),this._v("\n一个可执行程序 有且仅有 一个 main 包"),e("br")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("通过 import 关键字来导入其它非 main 包"),e("br"),this._v("\n通过 const 关键字来进行常量的定义"),e("br"),this._v("\n通过在函数体外部使用 var 关键字来进行全局变量的声明与赋值"),e("br"),this._v("\n通过 type 关键字来进行结构(struct)或接口(interface)的声明"),e("br"),this._v("\n通过 func 关键字来进行函数的声明"),e("br")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"数据类型查询"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据类型查询","aria-hidden":"true"}},[this._v("#")]),this._v(" 数据类型查询")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("a",{attrs:{href:"http://www.runoob.com/go/go-data-types.html"}},[this._v("传送门")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"常量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常量","aria-hidden":"true"}},[this._v("#")]),this._v(" 常量")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("常量的定义\n"),_("ul",[_("li",[t._v("常量的值在编译时就已经确定")]),t._v(" "),_("li",[t._v("常量的定义格式与变量基本相同")]),t._v(" "),_("li",[t._v("等号右侧必须是常量或者常量表达式")]),t._v(" "),_("li",[t._v("常量表达式中的函数必须是内置函数")])])]),t._v(" "),_("li",[t._v("常量的初始化规则与枚举\n"),_("ul",[_("li",[t._v("在定义常量组时，如果不提供初始值，则表示将使用上行的表达式")]),t._v(" "),_("li",[t._v("使用相同的表达式不代表具有相同的值")]),t._v(" "),_("li",[t._v("iota是常量的计数器，从0开始，组中每定义1个常量自动递增1")]),t._v(" "),_("li",[t._v("通过初始化规则与iota可以达到枚举的效果")]),t._v(" "),_("li",[t._v("每遇到一个const关键字，iota就会重置为0")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"if"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#if","aria-hidden":"true"}},[this._v("#")]),this._v(" if")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("判断语句if\n"),_("ul",[_("li",[t._v("条件表达式没有括号")]),t._v(" "),_("li",[t._v("支持一个初始化表达式（可以是并行方式）")]),t._v(" "),_("li",[t._v("左大括号必须和条件语句或else在同一行")]),t._v(" "),_("li",[t._v("支持单行模式")]),t._v(" "),_("li",[t._v("初始化语句中的变量为block级别，同时隐藏外部同名变量")]),t._v(" "),_("li",[t._v("1.0.3版本中的编译器BUG")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"for"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#for","aria-hidden":"true"}},[this._v("#")]),this._v(" for")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("循环语句for\n"),_("ul",[_("li",[t._v("Go只有for一个循环语句关键字，但支持3种形式")]),t._v(" "),_("li",[t._v("初始化和步进表达式可以是多个值")]),t._v(" "),_("li",[t._v("条件语句每次循环都会被重新检查，因此不建议在条件语句中")]),t._v(" "),_("li",[t._v("使用函数，尽量提前计算好条件并以变量或常量代替")]),t._v(" "),_("li",[t._v("左大括号必须和条件语句在同一行")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"switch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#switch","aria-hidden":"true"}},[this._v("#")]),this._v(" switch")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("选择语句switch\n"),_("ul",[_("li",[t._v("可以使用任何类型或表达式作为条件语句")]),t._v(" "),_("li",[t._v("不需要写break，一旦条件符合自动终止")]),t._v(" "),_("li",[t._v("如希望继续执行下一个case，需使用fallthrough语句")]),t._v(" "),_("li",[t._v("支持一个初始化表达式（可以是并行方式），右侧需跟分号")]),t._v(" "),_("li",[t._v("左大括号必须和条件语句在同一行")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"跳转"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#跳转","aria-hidden":"true"}},[this._v("#")]),this._v(" 跳转")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("跳转语句goto, break, continue\n"),_("ul",[_("li",[t._v("三个语法都可以配合标签使用")]),t._v(" "),_("li",[t._v("标签名区分大小写，若不使用会造成编译错误")]),t._v(" "),_("li",[t._v("Break与continue配合标签可用于多层循环的跳出")]),t._v(" "),_("li",[t._v("Goto是调整执行位置，与其它2个语句配合标签的结果并不相同")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组","aria-hidden":"true"}},[this._v("#")]),this._v(" 数组")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("数组Array\n"),_("ul",[_("li",[t._v("定义数组的格式：var Name>[n]type，n>=0")]),t._v(" "),_("li",[t._v("数组长度也是类型的一部分，因此具有不同长度的数组为不同类型")]),t._v(" "),_("li",[t._v("注意区分指向数组的指针和指针数组")]),t._v(" "),_("li",[t._v("数组在Go中为值类型")]),t._v(" "),_("li",[t._v("数组之间可以使用==或!=进行比较，但不可以使用<或>")]),t._v(" "),_("li",[t._v("可以使用new来创建数组，此方法返回一个指向数组的指针")]),t._v(" "),_("li",[t._v("Go支持多维数组")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"slice"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#slice","aria-hidden":"true"}},[this._v("#")]),this._v(" slice")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("切片Slice\n"),_("ul",[_("li",[t._v("其本身并不是数组，它指向底层的数组")]),t._v(" "),_("li",[t._v("作为变长数组的替代方案，可以关联底层数组的局部或全部")]),t._v(" "),_("li",[t._v("为引用类型")]),t._v(" "),_("li",[t._v("可以直接创建或从底层数组获取生成")]),t._v(" "),_("li",[t._v("使用len()获取元素个数，cap()获取容量")]),t._v(" "),_("li",[t._v("一般使用make()创建")]),t._v(" "),_("li",[t._v("如果多个slice指向相同底层数组，其中一个的值改变会影响全部")]),t._v(" "),_("li",[t._v("make([]T, len, cap)")]),t._v(" "),_("li",[t._v("其中cap可以省略，则和len的值相同")]),t._v(" "),_("li",[t._v("len表示存数的元素个数，cap表示容量")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"defer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#defer","aria-hidden":"true"}},[this._v("#")]),this._v(" defer")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[t._v("defer的执行方式类似其它语言中的析构函数，在函数体执行结束后")])]),t._v(" "),_("li",[_("p",[t._v("按照调用顺序的相反顺序逐个执行")])]),t._v(" "),_("li",[_("p",[t._v("即使函数发生严重错误也会执行")])]),t._v(" "),_("li",[_("p",[t._v("支持匿名函数的调用")])]),t._v(" "),_("li",[_("p",[t._v("常用于资源清理、文件关闭、解锁以及记录时间等操作")])]),t._v(" "),_("li",[_("p",[t._v("通过与匿名函数配合可在return之后修改函数计算结果")])]),t._v(" "),_("li",[_("p",[t._v("如果函数体内某个变量作为defer时匿名函数的参数，则在定义defer")])]),t._v(" "),_("li",[_("p",[t._v("时即已经获得了拷贝，否则则是引用某个变量的地址")])]),t._v(" "),_("li",[_("p",[t._v("Go 没有异常机制，但有 panic/recover 模式来处理错误")])]),t._v(" "),_("li",[_("p",[t._v("Panic 可以在任何地方引发，但recover只有在defer调用的函数中有效")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"结构struct"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结构struct","aria-hidden":"true"}},[this._v("#")]),this._v(" 结构struct")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[t._v("Go 中的struct与C中的struct非常相似，并且Go没有class")])]),t._v(" "),_("li",[_("p",[t._v("使用 type Name struct{} 定义结构，名称遵循可见性规则")])]),t._v(" "),_("li",[_("p",[t._v("支持指向自身的指针类型成员")])]),t._v(" "),_("li",[_("p",[t._v("支持匿名结构，可用作成员或定义成员变量")])]),t._v(" "),_("li",[_("p",[t._v("匿名结构也可以用于map的值")])]),t._v(" "),_("li",[_("p",[t._v("可以使用字面值对结构进行初始化")])]),t._v(" "),_("li",[_("p",[t._v("允许直接通过指针来读写结构成员")])]),t._v(" "),_("li",[_("p",[t._v("相同类型的成员可进行直接拷贝赋值")])]),t._v(" "),_("li",[_("p",[t._v("支持 == 与 !=比较运算符，但不支持 > 或 <")])]),t._v(" "),_("li",[_("p",[t._v("支持匿名字段，本质上是定义了以某个类型名为名称的字段")])]),t._v(" "),_("li",[_("p",[t._v("嵌入结构作为匿名字段看起来像继承，但不是继承")])]),t._v(" "),_("li",[_("p",[t._v("可以使用匿名字段指针")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"方法method"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法method","aria-hidden":"true"}},[this._v("#")]),this._v(" 方法method")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[t._v("Go 中虽没有class，但依旧有method")])]),t._v(" "),_("li",[_("p",[t._v("通过显示说明receiver来实现与某个类型的组合")])]),t._v(" "),_("li",[_("p",[t._v("只能为同一个包中的类型定义方法")])]),t._v(" "),_("li",[_("p",[t._v("Receiver 可以是类型的值或者指针")])]),t._v(" "),_("li",[_("p",[t._v("不存在方法重载")])]),t._v(" "),_("li",[_("p",[t._v("可以使用值或指针来调用方法，编译器会自动完成转换")])]),t._v(" "),_("li",[_("p",[t._v("从某种意义上来说，方法是函数的语法糖，因为receiver其实就是")])]),t._v(" "),_("li",[_("p",[t._v("方法所接收的第1个参数（Method Value vs. Method Expression）")])]),t._v(" "),_("li",[_("p",[t._v("如果外部结构和嵌入结构存在同名方法，则优先调用外部结构的方法")])]),t._v(" "),_("li",[_("p",[t._v("类型别名不会拥有底层类型所附带的方法")])]),t._v(" "),_("li",[_("p",[t._v("方法可以调用结构中的非公开字段")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"接口interface"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接口interface","aria-hidden":"true"}},[this._v("#")]),this._v(" 接口interface")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[t._v("接口是一个或多个方法签名的集合")])]),t._v(" "),_("li",[_("p",[t._v("只要某个类型拥有该接口的所有方法签名，即算实现该接口，无需显示")])]),t._v(" "),_("li",[_("p",[t._v("声明实现了哪个接口，这称为 Structural Typing")])]),t._v(" "),_("li",[_("p",[t._v("接口只有方法声明，没有实现，没有数据字段")])]),t._v(" "),_("li",[_("p",[t._v("接口可以匿名嵌入其它接口，或嵌入到结构中")])]),t._v(" "),_("li",[_("p",[t._v("将对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个")])]),t._v(" "),_("li",[_("p",[t._v("复制品的指针，既无法修改复制品的状态，也无法获取指针")])]),t._v(" "),_("li",[_("p",[t._v("只有当接口存储的类型和对象都为nil时，接口才等于nil")])]),t._v(" "),_("li",[_("p",[t._v("接口调用不会做receiver的自动转换")])]),t._v(" "),_("li",[_("p",[t._v("接口同样支持匿名字段方法")])]),t._v(" "),_("li",[_("p",[t._v("接口也可实现类似OOP中的多态")])]),t._v(" "),_("li",[_("p",[t._v("空接口可以作为任何类型数据的容器")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"反射reflection"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#反射reflection","aria-hidden":"true"}},[this._v("#")]),this._v(" 反射reflection")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[t._v("反射可大大提高程序的灵活性，使得 interface{} 有更大的发挥余地")])]),t._v(" "),_("li",[_("p",[t._v("反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息")])]),t._v(" "),_("li",[_("p",[t._v("反射会将匿名字段作为独立字段（匿名字段本质）")])]),t._v(" "),_("li",[_("p",[t._v("想要利用反射修改对象状态，前提是 interface.data 是 settable，")])]),t._v(" "),_("li",[_("p",[t._v("即 pointer-interface通过反射可以“动态”调用方法")])])])}],!1,null,null,null);e.default=r.exports}}]);