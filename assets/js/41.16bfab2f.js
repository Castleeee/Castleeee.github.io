(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{457:function(t,s,e){"use strict";e.r(s);var a=e(0),v=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"content"},[e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("p",[t._v("因为很多东西都在C中有，这里就只看看那些没有的")])]),t._v(" "),e("div",{attrs:{align:"center"}},[e("h1",[e("strong",[t._v("C++")])])]),t._v(" "),e("h2",{attrs:{id:"输入输出"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#输入输出","aria-hidden":"true"}},[t._v("#")]),t._v(" 输入输出")]),t._v(" "),e("h3",{attrs:{id:"一些规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一些规则","aria-hidden":"true"}},[t._v("#")]),t._v(" 一些规则")]),t._v(" "),e("p",[e("strong",[t._v("命名空间")]),e("br"),t._v("\n为了避免函数和变量名混乱我们使用命名空间来隔离开。调用的时候是"),e("code",[t._v("std::cout")]),t._v("使用了std空间里的cout函数"),e("br"),t._v("\n一般用std就够了。也可以直接using namespace std使用std下的所有东西。"),e("br"),t._v(" "),e("strong",[t._v("头文件引入")]),e("br"),t._v(" "),e("code",[t._v("#include < string >")]),t._v(" c没有string，c++引入就有了，c中很多库需要加c前缀。 "),e("code",[t._v("<>")]),t._v("从系统头文件中寻找，没有则报错，"),e("code",[t._v('""')]),t._v("先从非系统头文件找，没有再找系统头文件，不会报错")]),t._v(" "),e("h3",{attrs:{id:"标准io"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标准io","aria-hidden":"true"}},[t._v("#")]),t._v(" 标准IO")]),t._v(" "),e("p",[e("code",[t._v("#include < iostream >")]),t._v("标准输入输出流。在定义流对象时，系统会在内存中开辟一段缓冲区，用来暂存输入输出流的数据"),e("br"),t._v("\ncout是标准输出流对象插入到输出流中并输出到屏幕cout<<x<<endl;"),e("br"),t._v("\ncin是标准输入流对象，接受控制台输入的东西。cin>>x;"),e("br"),t._v("\nendl是尾部换行符（关于这个更多的google去吧，暂时用到这些）")]),t._v(" "),e("h3",{attrs:{id:"文件io"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件io","aria-hidden":"true"}},[t._v("#")]),t._v(" 文件IO")]),t._v(" "),e("p",[e("code",[t._v("#include < fstream >")]),t._v("文件输入输出流。")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("ofstream "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("oF")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"text.txt"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//打开一个文件对象")]),t._v("\noF"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("333")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"aaaaa\\n"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//写入一个txt文件里")]),t._v("\noF"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("close")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//记得关掉")]),t._v("\nifstream "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("iF")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"text.txt"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//输入一个文件对象的东西")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" d"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nstring str"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\niF"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v("d"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v("str"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//接收变量")]),t._v("\ncout"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("d"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("str"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//打印出来看看是啥")]),t._v("\n")])])]),e("p",[t._v("会txt就行了其他的不管了。")]),t._v(" "),e("h2",{attrs:{id:"函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数","aria-hidden":"true"}},[t._v("#")]),t._v(" 函数")]),t._v(" "),e("h3",{attrs:{id:"默认参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#默认参数","aria-hidden":"true"}},[t._v("#")]),t._v(" 默认参数")]),t._v(" "),e("p",[e("strong",[t._v("引用变量")])]),t._v(" "),e("blockquote",[e("p",[t._v("int a=3;\nint &r=a;//r是a的引用变量")])]),t._v(" "),e("p",[t._v("引用变量就是给变量起了个别名，指向同一块内存空间，定义的时候必须进行初始化而且必须保证类型匹配。引用变量定义之后就不能再更改指向其他人了。\n"),e("br"),t._v("主要做函数的形参。"),e("br"),t._v("\nc++的函数直接放进去是值传递"),e("code",[t._v("int f（int a,int b）{...}")]),t._v("调用f（x,y）不会对外部的x,y产生影响，因为函数自己开辟堆栈空间，ab只是复制了xy的值而没有真正拿到xy\n"),e("br"),t._v("\n解决方法:")]),t._v(" "),e("ul",[e("li",[t._v("传入俩指针，在函数内部对指针里的值进行修改，直接对内存修改。"),e("code",[t._v("int f（int *a,int *b）{...}")]),t._v("调用f（&x,&y）"),e("br")]),t._v(" "),e("li",[t._v("传入两个引用，不在函数内分配内存通过引用直接修改值。"),e("code",[t._v("int f（int &a,int &b）{...}")]),t._v("调用f（x,y）\n"),e("strong",[t._v("函数的默认参数")]),t._v("\n参数可以有默认值的，"),e("code",[t._v("int f（char r,int x=3）")]),t._v("，"),e("strong",[t._v("默认形参要靠右！")])])]),t._v(" "),e("h3",{attrs:{id:"函数重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数重载","aria-hidden":"true"}},[t._v("#")]),t._v(" 函数重载")]),t._v(" "),e("p",[t._v("c++允许定义两个名字相同的函数，但"),e("strong",[t._v("形参类型必须不要相同")]),t._v("，编译器会根据你传入的参数什么样子来调用不同的函数。\n函数名和形参列表构成了函数签名，函数重载不能根据返回值来区分。注意歧义的情况。")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("留坑\n")])])]),e("h3",{attrs:{id:"函数模板"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数模板","aria-hidden":"true"}},[t._v("#")]),t._v(" 函数模板")]),t._v(" "),e("p",[t._v("上例中的两个函数可以用函数模板进行重构。数据类型变为模板类型参数。\n"),e("code",[t._v("template <typename T>")]),t._v("定义了一个模板T")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("留坑\n")])])]),e("div",{staticClass:"warning custom-block"},[e("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),e("p",[t._v("注意调用时给定的数据类型是否支持函数的操作。"),e("br"),t._v("\n在重载函数中也可以像函数模板一样指定类型。")])]),t._v(" "),e("h2",{attrs:{id:"动态内存管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态内存管理","aria-hidden":"true"}},[t._v("#")]),t._v(" 动态内存管理")]),t._v(" "),e("p",[t._v("C++中使用"),e("code",[t._v("new")]),t._v("代替malloc。new除了分配内存外还会对对象进行初始化（new类对象的时候会调用构造函数等）。"),e("br"),t._v(" "),e("code",[t._v("new")]),t._v("完了一定要"),e("code",[t._v("delete")]),t._v("如果没被delete那么这块被分配的内存会一直存在没有名字，不被回收造成内存泄漏。")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("留坑\n")])])]),e("p",[t._v("指针指向new出来的新数组的时候实质上是指向数组的首地址")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("留坑\n")])])]),e("div",{staticClass:"danger custom-block"},[e("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),e("p",[t._v("delete 掉new type[] 申请的内存必须要用**"),e("code",[t._v("delete[] p")]),e("strong",[t._v("如果没有")]),e("code",[t._v("[]")]),t._v("**则只会删除数组的第一个元素值后面的元素会泄露")])]),t._v(" "),e("h2",{attrs:{id:"类和对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类和对象","aria-hidden":"true"}},[t._v("#")]),t._v(" 类和对象")]),t._v(" "),e("p",[t._v("传统的面向过程编程，C++引入了面向对象编程OOP"),e("a",{attrs:{href:"https://blog.csdn.net/it_man/article/details/6672964"}},[t._v("随便看一看吧后面再找个好的")])]),t._v(" "),e("h3",{attrs:{id:"类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类","aria-hidden":"true"}},[t._v("#")]),t._v(" 类")]),t._v(" "),e("p",[t._v('面向对象编程：程序是由不同种类的许多对象相互协作完成的。对象之间通过发送/接收消息来协作完成各种任务。由这些对象构成的程序也称为“对象式系统".\n'),e("br"),e("strong",[e("code",[t._v("class name{};")])]),t._v(" 定义类（你要非要用struct我也管不着）。类可以生成一个对象，类是对事物的特征抽象。通过类可以定义对象\n访问的时候使用**"),e("code",[t._v(".")]),e("strong",[t._v("。"),e("strong",[t._v("对象")]),t._v("同样具有指针\n看例子")]),t._v("注意后面有分号**")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("留坑\n")])])]),e("p",[t._v("类对象可以通过指针来访问，访问符号为"),e("code",[t._v("->")])]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("class_name stu"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//生成一个对象")]),t._v("\nclass_name "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("object_pointer"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("stu"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//给指针赋值")]),t._v("\nobject_pointer"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//访问了属性")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("object_pointer"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//访问了属性")]),t._v("\n\nclass_name "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("object_pointer"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("new class_name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//给指针赋动态对象（存储在堆）")]),t._v("\ndelete object_pointer"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//记得删除")]),t._v("\n")])])]),e("p",[t._v("成员可以有函数(行为)和变量(属性)。函数可以先在类中声明在后面实现。")]),t._v(" "),e("h3",{attrs:{id:"构造析构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构造析构","aria-hidden":"true"}},[t._v("#")]),t._v(" 构造析构")]),t._v(" "),e("p",[e("br"),t._v("对象在生成的时候实际上是通过一个"),e("code",[t._v("构造函数")]),t._v("来生成的，构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void，如果不在类中定义，c++会默认给一个空的"),e("code",[t._v("默认构造函数")]),t._v("，啥都不执行。\n"),e("br"),t._v("构造函数可以用来初始化成员变量。构造函数可以提供参数，在声明对象的时候就要传入对应的参数。\n"),e("br"),t._v("类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象(delete a;)时执行。\n"),e("br"),e("code",[t._v("析构函数")]),t._v("的名称与类的名称是完全相同的，只是在前面加波浪号"),e("code",[t._v("~")]),t._v("作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。"),e("a",{attrs:{href:"https://www.cnblogs.com/nzbbody/p/3523064.html"}},[t._v("构造析构")])]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("留坑\n")])])]),e("div",{staticClass:"warning custom-block"},[e("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),e("p",[t._v("自定义了构造函数之后不会再分配默认构造函数，也就不能直接声明对象数组。"),e("br"),t._v("\nstudent stu[3];会报错,存储指针或者用for添加进去")])]),t._v(" "),e("h3",{attrs:{id:"this指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this指针","aria-hidden":"true"}},[t._v("#")]),t._v(" this指针")]),t._v(" "),e("p",[t._v("类中的成员函数自带了一个this指针。比如"),e("code",[t._v("stu.print();==>print(&stu);")]),t._v("把类的指针传入。"),e("br"),t._v("\nvoid print(student *this){"),e("br"),t._v("\ncout<<"),e("code",[t._v("this->name")]),t._v('<<""<<'),e("code",[t._v("this->score")]),t._v("<<end1;"),e("br"),t._v("\n}"),e("br")]),t._v(" "),e("h2",{attrs:{id:"面向对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#面向对象","aria-hidden":"true"}},[t._v("#")]),t._v(" 面向对象")]),t._v(" "),e("h3",{attrs:{id:"封装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#封装","aria-hidden":"true"}},[t._v("#")]),t._v(" 封装")]),t._v(" "),e("p",[t._v("类中的成员默认为"),e("code",[t._v("private")]),t._v("只有本类中的成员才能调用，外部不能访问，声明一个类的时候通常要声明"),e("code",[t._v("public")]),t._v("和"),e("code",[t._v("private")]),t._v(".\n一般成员不声明设置为private，通过get/set方法进行设置和访问控制。参考java豆(bean)")]),t._v(" "),e("div",{staticClass:"language-ctypename extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("留坑\n")])])]),e("p",[t._v("封装是为了安全考虑。")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("属性")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("访问")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("private")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("能由1.该类中的函数2.其友元函数访问 不能被任何其他访问 该类的对象也不能访问")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("protected")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("能被1.该类中的函数2.子类的函数 以及3.其友元函数访问 但不能被该类的对象访问")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("public")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("可以被1.该类中的函数2.子类的函数3.其友元函数访问 也可以由4.该类的对象访问")])])])]),t._v(" "),e("p",[e("strong",[t._v("友元函数")]),e("br"),t._v("\n类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。"),e("br"),t._v("\n设为友元的普通的非成员函数,类内声明"),e("br"),t._v(" "),e("strong",[e("code",[t._v("friend void printWidth( Box box );")])]),e("br"),t._v("\n设为友元类中的所有成员函数,在class的public声明另一个类**"),e("code",[t._v("friend class ClassOther;")]),t._v("**"),e("br"),t._v("\n有缘不会被继承传递")]),t._v(" "),e("h3",{attrs:{id:"继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#继承","aria-hidden":"true"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),e("p",[t._v("子类继承父类子类就具有了父类的函数和数据成员。"),e("br"),t._v(" "),e("strong",[e("code",[t._v("class A: public A1, private A2")])]),e("br"),t._v("\n在声明类的时候有三种继承方式,我们几乎不使用 protected 或 private 继承")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("继承规则")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("public")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("protected")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("private")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("public继承")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("public")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("protected")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("不可用")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("protected继承")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("protected")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("protected")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("不可用")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("private继承")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("private")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("private")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("不可用")])])])]),t._v(" "),e("p",[t._v("下列属性是不能被继承的")]),t._v(" "),e("ul",[e("li",[t._v("基类的构造函数、析构函数和拷贝构造函数。")]),t._v(" "),e("li",[t._v("基类的重载运算符。")]),t._v(" "),e("li",[t._v("基类的友元函数")])]),t._v(" "),e("p",[t._v("可以多继承，但是要注意棱形继承多态问题"),e("br"),t._v("\n简单的继承关系示例")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("留坑\n")])])]),e("h3",{attrs:{id:"多态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多态","aria-hidden":"true"}},[t._v("#")]),t._v(" 多态")]),t._v(" "),e("p",[e("strong",[e("h4",[t._v("虚继承")])]),e("br")]),t._v(" "),e("blockquote",[e("p",[t._v("class A;\nclass B:vitual public A;\nclass C:vitual public A;\nclass D:public B,public C;")])]),t._v(" "),e("p",[e("strong",[e("h4",[t._v("虚基类")])]),e("br"),t._v(" "),e("strong",[e("h4",[t._v("虚函数")])]),e("br"),t._v(" "),e("strong",[e("h4",[t._v("纯虚函数")])]),e("br"),t._v(" "),e("strong",[e("h4",[t._v("抽象类(接口)")])]),e("br"),t._v("\n为了解决棱形继承问题，由此有了虚继承")]),t._v(" "),e("h3",{attrs:{id:"类模板"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类模板","aria-hidden":"true"}},[t._v("#")]),t._v(" 类模板")]),t._v(" "),e("p",[t._v("C++通过类模板来实现泛型支持。和声明函数模板一样，声明一个类型**"),e("code",[t._v("template <class T>")]),e("strong",[t._v(",在类中使用T类型，声明对象的时候指明类型即可Class")]),t._v("< type >**(a,b)")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("留坑https"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("www"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("jianshu"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("com"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("p"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("70")]),t._v("ca94872418\n")])])]),e("ul",[e("li",[t._v("如果父类自定义了构造函数，记得子类要调用父类构造函数来初始化")]),t._v(" "),e("li",[t._v("继承的时候，如果子类不是模板类，则必须指明当前的父类的类型，因为要分配内存空间class ChildOne:public Parent< int >")]),t._v(" "),e("li",[t._v("继承的时候，如果子类是模板类，要么指定父类的类型，要么用子类的泛型来指定父类class ChildTwo:public Parent< T >\n-----from "),e("a",{attrs:{href:"http://www.runoob.com/cplusplus/cpp-templates.html"}},[t._v("菜鸟")]),t._v("，"),e("a",{attrs:{href:"https://www.jianshu.com/p/70ca94872418"}},[t._v("一个人的简书")])])]),t._v(" "),e("h3",{attrs:{id:"运算符重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运算符重载","aria-hidden":"true"}},[t._v("#")]),t._v(" 运算符重载")]),t._v(" "),e("p",[t._v("在类内部声明被重载的运算符，可以使用运算符进行操作类对象。"),e("br"),t._v(" "),e("strong",[e("code",[t._v("B operator+(B &b1,B &b2){ ... return B b;}<br/>")])]),e("br"),t._v("\n在类内部声明一下这个运算符一样的函数，然后调用的时候就可直接加减了。"),e("br")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}},[t._v("可重载")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}})])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("双目算术运算符")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("+")]),t._v("(加)，"),e("code",[t._v("-")]),t._v("(减)，"),e("code",[t._v("*")]),t._v("(乘)，"),e("code",[t._v("/")]),t._v("(除)，"),e("code",[t._v("%")]),t._v("(取模)")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("关系运算符")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("==")]),t._v("(等于)，"),e("code",[t._v("!=")]),t._v("(不等于)，"),e("code",[t._v("<")]),t._v("(小于)，"),e("code",[t._v(">")]),t._v("(大于)，"),e("code",[t._v("<=")]),t._v("(小于等于)，"),e("code",[t._v(">=")]),t._v("(大于等于)")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("逻辑运算符")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("｜｜")]),t._v("(逻辑或)，"),e("code",[t._v("&&")]),t._v("(逻辑与)，"),e("code",[t._v("!")]),t._v("(逻辑非)")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("单目运算符")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("+")]),t._v("(正)，"),e("code",[t._v("-")]),t._v("(负)，"),e("code",[t._v("*")]),t._v("(指针)，"),e("code",[t._v("&")]),t._v("(取地址)")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("自增自减运算符")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("++")]),t._v("(自增)，"),e("code",[t._v("--")]),t._v("(自减)")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("位运算符")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("｜")]),t._v("(按位或)，"),e("code",[t._v("&")]),t._v("(按位与)，"),e("code",[t._v("~")]),t._v("(按位取反)，"),e("code",[t._v("^")]),t._v("(按位异或),，"),e("code",[t._v("<<")]),t._v("(左移)，"),e("code",[t._v(">>")]),t._v("(右移)")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("赋值运算符")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("=")]),t._v(", "),e("code",[t._v("+=")]),t._v(", "),e("code",[t._v("-=")]),t._v(", "),e("code",[t._v("*=")]),t._v(", "),e("code",[t._v("/=")]),t._v(" , "),e("code",[t._v("% =")]),t._v(", "),e("code",[t._v("&=")]),t._v(", "),e("code",[t._v("｜=")]),t._v(","),e("code",[t._v("^=")]),t._v(", "),e("code",[t._v("<<=")]),t._v(", "),e("code",[t._v(">>=")])])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("空间申请与释放")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("new")]),t._v(", "),e("code",[t._v("delete")]),t._v(", "),e("code",[t._v("new[ ]")]),t._v(" , "),e("code",[t._v("delete[]")])])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("其他运算符")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[e("code",[t._v("()")]),t._v("(函数调用)，"),e("code",[t._v("->")]),t._v("(成员访问)，"),e("code",[t._v(",")]),t._v("(逗号)，"),e("code",[t._v("[]")]),t._v("(下标)")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("不可重载")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("code",[t._v(".")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("成员访问运算符")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("code",[t._v(".*")]),t._v(", "),e("code",[t._v("->*")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("成员指针访问运算符")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("code",[t._v("::")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("域运算符")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("code",[t._v("sizeof")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("长度运算符")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("code",[t._v("?:")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("条件运算符")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("code",[t._v("#")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("预处理符号")])])])]),t._v(" "),e("p",[t._v("-----from 菜鸟"),e("br"),t._v("\n原则:")]),t._v(" "),e("ul",[e("li",[t._v("运算重载符不可以改变语法结构。")]),t._v(" "),e("li",[t._v("运算重载符不可以改变操作数的个数。")]),t._v(" "),e("li",[t._v("运算重载符不可以改变优先级。")]),t._v(" "),e("li",[t._v("运算重载符不可以改变结合性。")])]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("留坑\n")])])]),e("h2",{attrs:{id:"异常处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异常处理","aria-hidden":"true"}},[t._v("#")]),t._v(" 异常处理")]),t._v(" "),e("p",[t._v("C++中有了try 和catch"),e("br"),t._v("\n用法和py，java中相似。"),e("br")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("try"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("catch")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" 错误名字 e1 "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\ne1"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"你出错了"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("catch")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("错误 e2"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\nthrow "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"出错了"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("自己定义一下出了什么错该怎么办，比如e1被打印了出来，e2就没管。"),e("br"),t._v("自己查一下"),e("a",{attrs:{href:"http://www.runoob.com/cplusplus/cpp-exceptions-handling.html"}},[t._v("错误类型")]),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"stl"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stl","aria-hidden":"true"}},[t._v("#")]),t._v(" STL")]),t._v(" "),e("p",[e("a",{attrs:{href:"http://c.biancheng.net/stl/"}},[t._v("C语言中文网的STL")]),t._v("(多到我不想整理不会的就去查把)我随意整理下"),e("br"),t._v("\nC++ STL中标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：红黑树")]),t._v(" "),e("h3",{attrs:{id:"向量vector"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#向量vector","aria-hidden":"true"}},[t._v("#")]),t._v(" 向量vector")]),t._v(" "),e("p",[t._v("vector< T > 容器是包含 T 类型元素的序列容器，和 array<T，N> 容器相似，不同的是 vector< T > 容器的大小可以自动增长，从而可以包含任意数量的元素；因此类型参数 T 不再需要模板参数 N。只要元素个数超出 vector 当前容量，就会自动分配更多的空间。只能在容器尾部高效地删除或添加元素。\n线性排序，可以下标访问\n"),e("strong",[e("code",[t._v("#include <vector>")])])]),t._v(" "),e("ul",[e("li",[e("strong",[e("code",[t._v("vector<DataType>Name(MaxSize,defaultValue);")])]),t._v(" "),e("ul",[e("li",[t._v("定义一个vector")])])]),t._v(" "),e("li",[t._v("x="),e("strong",[e("code",[t._v("Name[i];")]),e("strong",[t._v("或")]),e("code",[t._v("Name.at(i)")])]),t._v(" "),e("ul",[e("li",[t._v("取出了第i个元素")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("Name.push_back(i);")])]),t._v(" "),e("ul",[e("li",[t._v("在数组的最后添加一个数据")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("Name.pop_back();")])]),t._v(" "),e("ul",[e("li",[t._v("去掉数组的最后一个数据")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("Name.begin/end")])]),t._v(" "),e("ul",[e("li",[t._v("得到数组头/尾的指针")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("Name.front/back")])]),t._v(" "),e("ul",[e("li",[t._v("得到数组头/尾的- 引用")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("Name.size()")])]),t._v(" "),e("ul",[e("li",[t._v("得到数组的长度")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("Name.clear()")])]),t._v(" "),e("ul",[e("li",[t._v("清空当前的vector")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("Name.empty()")])]),t._v(" "),e("ul",[e("li",[t._v("是ture否false")])])])]),t._v(" "),e("h3",{attrs:{id:"队列queue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#队列queue","aria-hidden":"true"}},[t._v("#")]),t._v(" 队列queue")]),t._v(" "),e("p",[e("strong",[e("code",[t._v("#include<queue>")])]),e("br"),t._v(" "),e("strong",[t._v("先进先出队列 < queue >")]),e("br"),t._v("\n定义"),e("code",[t._v("queue<Type> M")]),e("br")]),t._v(" "),e("ul",[e("li",[t._v("查看是否为空队列 "),e("strong",[e("code",[t._v("M.empty()")])]),t._v(" 是的话返回1，不是返回0;")]),t._v(" "),e("li",[t._v("从已有元素后面增加元素 "),e("strong",[e("code",[t._v("M.push(x)")])])]),t._v(" "),e("li",[t._v("输出现有元素的个数 "),e("strong",[e("code",[t._v("M.size()")])])]),t._v(" "),e("li",[t._v("清除队顶元素 "),e("strong",[e("code",[t._v("M.pop()")])]),t._v(" ,同样它不返回值")]),t._v(" "),e("li",[t._v("获取队顶元素 "),e("strong",[e("code",[t._v("M.front()")])])]),t._v(" "),e("li",[t._v("获取队尾元素 "),e("strong",[e("code",[t._v("M.back()")])])])]),t._v(" "),e("p",[e("strong",[t._v("优先级队列 < queue >")]),t._v(" "),e("a",{attrs:{href:"https://blog.csdn.net/xiaoquantouer/article/details/52015928"}},[t._v("这个挺详细的")]),e("br"),t._v("\n定义的时候要决定优先值"),e("br"),t._v(" "),e("code",[t._v("priority_queue< int >Q;")]),t._v("默认优先输出大的数据(整数)，可以自己定义"),e("br"),t._v("\n优先输出小数据 "),e("code",[t._v("priority_queue<int, vector<int>, greater<int> > p;")]),e("br"),t._v("\n自己重载例子"),e("br")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("y"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Node")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n\t\t"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("x")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("y")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("cmp")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tbool "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("operator")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Node a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Node b"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" b"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\t"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("y"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("b"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("y"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("b"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tpriority_queue"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Node"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" vector"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Node"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" cmp"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("p"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("ul",[e("li",[e("strong",[e("code",[t._v("Q.empty()")])]),t._v(" 判断队列是否为空返回ture表示空返回false表示空 bool")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("Q.top()")])]),t._v(" 返回顶端元素的值元素还在队列里")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("Q.pop()")])]),t._v(" 删除顶端元素 void")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("Q.push(V)")])]),t._v(" 把long long型的数V加入到队列里它会制动条件V的位置void")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("Q.size()")])]),t._v(" 返回队列里元素个数 unsigned int")])]),t._v(" "),e("p",[e("strong",[t._v("双端队列")])]),t._v(" "),e("ul",[e("li",[e("strong",[e("code",[t._v("deque<int>c")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("c.pop_back()")])]),t._v("      删除最后一个数据。")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("c.pop_front()")])]),t._v("      删除头部数据。")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("c.push_back(elem)")])]),t._v("  在尾部加入一个数据。")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("c.push_front(elem)")])]),t._v(" 在头部插入一个数据。")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("c.clear()")])]),t._v("          移除容器中所有数据。")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("c.front()")])]),t._v("          传回地一个数据。")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("c.back()")])]),t._v("          传回最后一个数据，不检查这个数据是否存在。")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("c.size()")])]),t._v("           返回容器中实际数据的个数。")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("c.empty()")])]),t._v("         判断容器是否为空。")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("c[i]")])]),t._v(" 等同于 "),e("strong",[e("code",[t._v("c.at(i)")])]),t._v(";")])]),t._v(" "),e("h3",{attrs:{id:"链表list"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#链表list","aria-hidden":"true"}},[t._v("#")]),t._v(" 链表list")]),t._v(" "),e("p",[t._v("由节点组成的双向链表，每个结点包含着一个元素\n"),e("strong",[e("code",[t._v("list<int> list1(1,2,3)")])])]),t._v(" "),e("ul",[e("li",[e("strong",[e("code",[t._v("list.front()")])]),t._v(" "),e("ul",[e("li",[t._v("返回第一个元素的引用")]),t._v(" "),e("li",[t._v("int nRet =list1.front()// nRet = 1")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("list.back()")])]),t._v(" "),e("ul",[e("li",[t._v("返回最后一元素的引用")]),t._v(" "),e("li",[t._v("int nRet =list1.back()// nRet = 3")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("list.push_back(x)")])]),t._v(" "),e("ul",[e("li",[t._v("增加一元素到链表尾")]),t._v(" "),e("li",[t._v("list1.push_back(4)//list1(1,2,3,4)")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("list.push_front(x)")])]),t._v(" "),e("ul",[e("li",[t._v("增加一元素到链表头")]),t._v(" "),e("li",[t._v("list1.push_front(4)//list1(4,1,2,3)")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("list.pop_back()")])]),t._v(" "),e("ul",[e("li",[t._v("删除链表尾的一个元素")]),t._v(" "),e("li",[t._v("list1.pop_back()//list1(1,2)")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("list.pop_front()")])]),t._v(" "),e("ul",[e("li",[t._v("删除链表头的一元素")]),t._v(" "),e("li",[t._v("list1.pop_front()//list1(2,3)")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("list.clear()")])]),t._v(" "),e("ul",[e("li",[t._v("删除所有元素")]),t._v(" "),e("li",[t._v("list1.clear();// list1空了,list1.size()=0")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("list.sort()")])]),t._v(" "),e("ul",[e("li",[t._v("对链表排序，默认升序(可自定义回调函数)")]),t._v(" "),e("li",[t._v("定义回调函数")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("list.insert(指针,[几次],元素)")])]),t._v(" "),e("ul",[e("li",[t._v("在指定位置插入一个或多个元素")]),t._v(" "),e("li",[t._v("list1.insert(++list1.begin(),9);  // list1(1,9,2,3);")]),t._v(" "),e("li",[t._v("list1.insert(list1.begin(),2,9);  // list1(9,9,1,2,3);")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("list.swap()")])]),t._v(" "),e("ul",[e("li",[t._v("交换两个链表(两个重载)")]),t._v(" "),e("li",[t._v("list1.swap(list2);//list1（1，2，3） list2（4，5，6）->list1（4，5，6） list2（1，2，3）")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("list1.unique()")])]),t._v(" "),e("ul",[e("li",[t._v("删除相邻重复元素L1(1,1,4,3,5,1)->L1(1,4,3,5,1)")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("merge()")])]),t._v(" "),e("ul",[e("li",[t._v("合并两个有序链表并使之有序")]),t._v(" "),e("li",[t._v("升序list1.merge(list2);->list1(1,2,3,4,5,6) list2现为空")]),t._v(" "),e("li",[t._v("降序list1.merge(list2, greater< int >()); //list1(6,5,4,3,2,1) list2现为空")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("list.reverse()")])]),t._v(" "),e("ul",[e("li",[t._v("反转链表list1（1，2，3）->list1(3,2,1)")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("list1.remove(4)")])]),t._v(" "),e("ul",[e("li",[t._v("删除链表中匹配值的元素(匹配元素全部删除4)")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("bool bRet =L1.empty();")])]),t._v(" "),e("ul",[e("li",[t._v("判断是否链表为空true/false")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("rbegin()")])]),t._v(" "),e("ul",[e("li",[t._v("返回链表最后一元素的后向指针(reverse_iteratoror const)list< int>::reverse_iterator it = list1.rbegin();  //*it = 3")])])]),t._v(" "),e("li",[e("strong",[e("code",[t._v("rend()")])]),t._v(" "),e("ul",[e("li",[t._v("返回链表第一元素的下一位置的后向指针list< int>::reverse_iteratorit = list1.rend(); // *(--riter) =")])])])]),t._v(" "),e("h3",{attrs:{id:"元组tuple"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#元组tuple","aria-hidden":"true"}},[t._v("#")]),t._v(" 元组tuple")]),t._v(" "),e("h3",{attrs:{id:"集合set"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集合set","aria-hidden":"true"}},[t._v("#")]),t._v(" 集合set")]),t._v(" "),e("p",[t._v("由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序 < set >\n元素不能重复,貌似看到了一个"),e("a",{attrs:{href:"https://blog.csdn.net/changjiale110/article/details/79108447"}},[t._v("原理解析")]),t._v("有兴趣的传送过去看看"),e("br"),t._v("\nset< type >: 以less< >为排序法则的set"),e("br"),t._v("\nset< type,op >: 以op为排序法则的set"),e("br"),t._v("\nps:我也不知道啥意思，不深究了，拿来即用碰到在查就行"),e("br")]),t._v(" "),e("h3",{attrs:{id:"映射map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#映射map","aria-hidden":"true"}},[t._v("#")]),t._v(" 映射map")]),t._v(" "),e("p",[t._v("根据key值快速查找记录，查找的复杂度基本是Log(N)，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次\n"),e("code",[t._v("map<int, string> m;")]),t._v("定义了键是整数值是字符串的一个字典\n插入")]),t._v(" "),e("ul",[e("li",[e("code",[t._v('m.insert(pair<int, string>(1, "s1"));')])]),t._v(" "),e("li",[e("code",[t._v('m.insert(map<int, string>::value_type (2, "student_two"));')]),t._v("//和上面的插入有啥不一样")]),t._v(" "),e("li",[e("code",[t._v('m[3] = "student_three";')]),t._v("//字符串也可以这样取")])]),t._v(" "),e("div",{staticClass:"warning custom-block"},[e("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),e("p",[t._v("当map中有这个关键字时，insert插入不了，但是用数组方式可以覆盖以前该关键字对应的值")])]),t._v(" "),e("p",[t._v("迭代")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("for(iter = m=.begin(); iter != m=.end(); iter++){...}")])]),t._v(" "),e("li",[e("code",[t._v("map.size()")]),t._v("\n查找")]),t._v(" "),e("li",[e("code",[t._v("iter = mapStudent.find(1);")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("iter->second")]),t._v(" 通过map对象的方法获取的iterator数据类型是一个std::pair对象，包括两个数据 "),e("code",[t._v("iterator->first")]),t._v(" 和 "),e("code",[t._v("iterator->second")]),t._v(" 分别代表关键字和存储的数据。\n交换和排序")])])]),t._v(" "),e("li",[t._v("map中的swap不是一个容器中的元素交换，而是两个容器所有元素的交换。")]),t._v(" "),e("li",[t._v("map中的元素是自动按Key升序排序，所以不能对map用sort函数；\n函数")]),t._v(" "),e("li",[e("code",[t._v("begin()")]),t._v(" 返回指向map头部的迭代器")]),t._v(" "),e("li",[e("code",[t._v("clear()")]),t._v("删除所有元素")]),t._v(" "),e("li",[e("code",[t._v("count()")]),t._v(" 返回指定元素出现的次数")]),t._v(" "),e("li",[e("code",[t._v("empty()")]),t._v(" 如果map为空则返回true")]),t._v(" "),e("li",[e("code",[t._v("end()")]),t._v("   返回指向map末尾的迭代器")]),t._v(" "),e("li",[e("code",[t._v("erase()")]),t._v("         删除一个元素")]),t._v(" "),e("li",[e("code",[t._v("find()")]),t._v("          查找一个元素")]),t._v(" "),e("li",[e("code",[t._v("size()")]),t._v("          返回map中元素的个数")]),t._v(" "),e("li",[e("code",[t._v("swap()")]),t._v("           交换两个map")]),t._v(" "),e("li",[e("code",[t._v("max_size()")]),t._v("      返回可以容纳的最大元素个数")])]),t._v(" "),e("h3",{attrs:{id:"栈stack"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#栈stack","aria-hidden":"true"}},[t._v("#")]),t._v(" 栈stack")]),t._v(" "),e("p",[t._v("后进先出的值的排列 < stack >")]),t._v(" "),e("p",[e("code",[t._v("stack<int> s;")])]),t._v(" "),e("ul",[e("li",[e("strong",[e("code",[t._v("s.push(x);")])]),t._v(" 入栈")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("s.pop();")])]),t._v(" 出栈")])]),t._v(" "),e("div",{staticClass:"warning custom-block"},[e("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),e("p",[t._v("注意，出栈操作只是删除栈顶元素，并不返回该元素。")])]),t._v(" "),e("ul",[e("li",[e("strong",[e("code",[t._v("s.top()")])]),t._v(" 返回栈顶")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("s.empty()")])]),t._v(" 当栈空时，返回true。")]),t._v(" "),e("li",[e("strong",[e("code",[t._v("s.size()")])]),t._v(" 访问栈中的元素个数")])]),t._v(" "),e("h3",{attrs:{id:"字符串string"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字符串string","aria-hidden":"true"}},[t._v("#")]),t._v(" 字符串string")]),t._v(" "),e("p",[t._v("众所周知C++处理字符串有点难过。不做最好用的库就是"),e("code",[t._v("#include <string>")]),t._v(",别带h。"),e("br"),t._v(" "),e("strong",[t._v("声明:")]),e("br"),t._v(" "),e("code",[t._v('string s;string s="abcd";')]),t._v("或者"),e("code",[t._v('string s="a b cd";string s("xtsy")')]),t._v("这样。（空格也会被算进去的"),e("br"),t._v(" "),e("strong",[t._v("输入:")]),e("br"),t._v(" "),e("code",[t._v("cin>>s;")]),t._v("            不能读入空格，以空格、制表符、回车符作为结束标志"),e("br"),t._v(" "),e("code",[t._v("getline(cin,s);")]),t._v("   可以读入空格和制表符，以回车符作为结束标志"),e("br"),t._v(" "),e("strong",[t._v("长度:")]),e("br"),t._v(" "),e("code",[t._v("int len=s.size();")]),t._v("    或者"),e("code",[t._v("int len=s.length();")]),t._v("返回一个int"),e("br"),t._v(" "),e("code",[t._v("bool=s.empty();")]),t._v("        当前字符串是否为空"),e("br"),t._v(" "),e("strong",[t._v("下标字符:")]),e("br"),t._v(" "),e("code",[t._v("s[i]")]),t._v("或 "),e("code",[t._v("char c=s.at(i)")]),t._v("返回的是一个char。"),e("br"),t._v(" "),e("strong",[t._v("转换:")]),e("br"),t._v(" "),e("code",[t._v("s=str;string")]),t._v("类型=char数组;重载了运算符，直接就能转换。"),e("br"),t._v(" "),e("code",[t._v('#include "string.h"')]),e("br"),t._v(" "),e("code",[t._v("strcpy(str,s.c_str());")]),e("br"),t._v(" "),e("strong",[t._v("比较:")]),e("br"),t._v(" "),e("code",[t._v("if(s1<s2);或s1.compare(s2);")]),e("br"),t._v("\n真返回1假返回-1"),e("br"),t._v(" "),e("strong",[t._v("拼接:")]),e("br"),t._v(" "),e("code",[t._v("s1=s1+s2;")]),t._v("或"),e("code",[t._v("s1.append(s2);")]),e("br"),t._v(" "),e("strong",[t._v("查找:")]),e("br"),t._v(" "),e("code",[t._v("s.find(s1)")]),t._v("    查找s中第一次出现s1的位置，并返回（包括0）"),e("br"),t._v(" "),e("code",[t._v("s.rfind(s1)")]),t._v("   查找s中最后次出现s1的位置，并返回（包括0）"),e("br"),t._v(" "),e("code",[t._v("s.find_first_of(s1)")]),t._v("     查找在s1中任意一个字符在s中第一次出现的位置，并返回（包括0）"),e("br"),t._v(" "),e("code",[t._v("s.find_last_of(s1)")]),t._v("    查找在s1中任意一个字符在s中最后一次出现的位置，并返回（包括0）"),e("br"),t._v(" "),e("code",[t._v("s.find_first_not_of(s1)")]),t._v("      查找s中第一个不属于s1中的字符的位置，并返回（包括0）"),e("br"),t._v(" "),e("code",[t._v("s.find_last_not_of(s1)")]),t._v("     查找s中最后一个不属于s1中的字符的位置，并返回（包括0）"),e("br")]),t._v(" "),e("p",[e("strong",[t._v("插入:")]),e("br"),t._v(" "),e("code",[t._v("s.insert(p,s);")]),t._v("在p0位置插入字符串s"),e("br"),t._v(" "),e("code",[t._v("s.insert(p,s,n);")]),t._v("在p0位置插入字符串s的前n个字符"),e("br"),t._v(" "),e("code",[t._v("s.insert(p,s);")]),t._v("在p0位置插入字符串s"),e("br"),t._v(" "),e("code",[t._v("s.insert(p,s,pos,n);")]),t._v("在p0位置插入字符串s从pos下标(整数)开始的连续n个字符"),e("br"),t._v(" "),e("code",[t._v("s.insert(p, n,c);")]),t._v("在p0处插入n个字符c"),e("br")]),t._v(" "),e("p",[e("strong",[t._v("截取:")]),e("br"),t._v(" "),e("code",[t._v("s=s.substr(pos, n)")]),t._v("  截取s中从pos开始（包括0）的n个字符的子串，并返回"),e("br"),t._v(" "),e("code",[t._v("s=s.substr(pos)")]),t._v("      截取s中从从pos开始（包括0）到末尾的所有字符的子串，并返回"),e("br"),t._v(" "),e("strong",[t._v("反转:")]),e("br"),t._v(" "),e("code",[t._v("#include<algorithm>")]),e("br"),t._v(" "),e("code",[t._v("reverse(s.begin(),s.end());")]),e("br")]),t._v(" "),e("div",{staticClass:"warning custom-block"},[e("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),e("p",[t._v("反转不返回会直接对原来的字符串进行操作")])]),t._v(" "),e("p",[e("strong",[t._v("替换:")]),e("br"),t._v(" "),e("code",[t._v("s.replace(pos, n, s1)")]),t._v("     用s1替换s中从pos开始（包括0）的n个字符的子串"),e("br"),t._v(" "),e("code",[t._v("#include<algorithm>")]),e("br"),t._v(" "),e("code",[t._v("replace(str.begin(),str.end(),'a','b');")]),t._v("从开始到结尾a替换成b，也是对原串操作，而且只能对单个字符进行操作"),e("br")]),t._v(" "),e("h2",{attrs:{id:"参考资料列表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料列表","aria-hidden":"true"}},[t._v("#")]),t._v(" 参考资料列表")]),t._v(" "),e("p",[t._v("整理的时候想整理成一个来着，发现太长了就分成了俩，于是参考资料列表也在c中。")])])}],!1,null,null,null);s.default=v.exports}}]);